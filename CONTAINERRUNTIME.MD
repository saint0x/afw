# Hermetic Container Runtime: Architectural Principles & Implementation Plan

> **Core Principle: Agent Sovereignty. Secure Execution Platform.**
>
> The agent is the **sole arbiter** of container lifecycles and orchestration decisions. The runtime provides a secure, hermetic execution platform that faithfully executes the agent's container management commands without imposing lifecycle assumptions.
>
> **Every non-conversational action is a containerized workload**, but the agent decides:
> - When to create containers
> - How long to keep them alive  
> - What to execute inside them
> - When to destroy them
> - How to network them together
>
> The runtime's role is to provide **secure primitives** and **intelligent abstractions**, not to make orchestration decisions for the agent.

---

## The Two-Tiered Tool Architecture

### 1. `ToolScope::Primitive` (Agent's Control Panel)
The exhaustive, low-level suite of tools that provides direct, programmatic control over the `quilt` subsystem. **These are the agent's primary interface** for container orchestration.

- **Full Container Lifecycle**: `createContainer`, `startContainer`, `stopContainer`, `removeContainer`, `execInContainer`
- **Introspection & Monitoring**: `listContainers`, `getContainerStatus`, `getContainerLogs`, `getSystemMetrics`
- **Network Management**: `getNetworkTopology`, `getContainerNetworkInfo`, `establishConnection`, `severConnection`
- **Resource Management**: `setResourceLimits`, `getResourceUsage`, `attachVolume`, `detachVolume`
- **Image Management**: `pullImage`, `buildImage`, `listImages`, `removeImage`

**Agent Authority**: The agent has complete autonomy over when and how to use these tools. It can:
- Maintain long-running service containers
- Create ephemeral task containers  
- Build complex multi-container applications
- Manage container networks and communication
- Implement its own lifecycle strategies

### 2. `ToolScope::Cognitive` (LLM-Powered Analysis)
High-level tools that provide LLM-powered cognitive capabilities for reasoning, research, and content analysis. **These complement primitive tools** but never hide container operations.

- **Examples**: `ponderTool`, `webSearchTool`, `parseDocumentTool`, `writeCodeTool`
- **Execution**: Direct LLM calls for cognitive tasks - no container abstraction layer
- **Transparency**: Cognitive tools are clearly separate from container operations
- **Agent Choice**: Agents use primitives for container work, cognitive tools for analysis

---

## Implementation Checklist

### Phase 1: Foundational Tooling & Dependency Injection âœ…
- [âœ…] **Architecture:** Create new module `tools::container`.
- [âœ…] **DI:** Refactor `AriaEngines` to instantiate `QuiltService` and inject it into the `ToolRegistry`.
- [âœ…] **DI:** Refactor `ToolRegistry` to accept and hold the `ContainerManager` dependency.
- [âœ…] **Tool Registration:** Add a new `register_container_tools` function to the `ToolRegistry`.

### Phase 2: Core Lifecycle & Execution Primitives âœ…
- [âœ…] **`createContainer`**: `tools::container::create.rs`
- [âœ…] **`startContainer`**: `tools::container::start.rs`
- [âœ…] **`execInContainer`**: `tools::container::exec.rs`
- [âœ…] **`stopContainer`**: `tools::container::stop.rs`
- [âœ…] **`removeContainer`**: `tools::container::remove.rs`

### Phase 3: Introspection & Monitoring Primitives âœ…
- [âœ…] **`listContainers`**: `tools::container::list.rs`
- [âœ…] **`getContainerStatus`**: `tools::container::status.rs`
- [âœ…] **`getContainerLogs`**: `tools::container::logs.rs`
- [âœ…] **`getSystemMetrics`**: `tools::container::metrics.rs`

### Phase 4: Networking & Service Mesh Primitives
- [âœ…] **`getNetworkTopology`**: `tools::container::network_topology.rs`
- [âœ…] **`getContainerNetworkInfo`**: `tools::container::network_info.rs`
- [ ] **`establishConnection`**: `tools::container::network_connect.rs`
- [ ] **`severConnection`**: `tools::container::network_disconnect.rs`

### Phase 5: Resource & Volume Management Primitives
- [ ] **`setResourceLimits`**: `tools::container::resources.rs`
- [ ] **`getResourceUsage`**: `tools::container::resource_usage.rs`
- [ ] **`attachVolume`**: `tools::container::volume_attach.rs`
- [ ] **`detachVolume`**: `tools::container::volume_detach.rs`
- [ ] **`createVolume`**: `tools::container::volume_create.rs`
- [ ] **`removeVolume`**: `tools::container::volume_remove.rs`

### Phase 6: Image Management Primitives
- [ ] **`pullImage`**: `tools::container::image_pull.rs`
- [ ] **`buildImage`**: `tools::container::image_build.rs`
- [ ] **`listImages`**: `tools::container::image_list.rs`
- [ ] **`removeImage`**: `tools::container::image_remove.rs`
- [ ] **`inspectImage`**: `tools::container::image_inspect.rs`

### Phase 7: Advanced Container Operations
- [ ] **`copyToContainer`**: `tools::container::copy_to.rs`
- [ ] **`copyFromContainer`**: `tools::container::copy_from.rs`
- [ ] **`pauseContainer`**: `tools::container::pause.rs`
- [ ] **`unpauseContainer`**: `tools::container::unpause.rs`
- [ ] **`restartContainer`**: `tools::container::restart.rs`
- [ ] **`commitContainer`**: `tools::container::commit.rs`

### Phase 8: Runtime Integration & Agent Empowerment
- [âœ…] **`ExecutionEngine`:** ~~Implement the "Realizer" logic~~ **DEPRECATED - Realizer removed for clean architecture**
- [âœ…] **ðŸš¨ CRITICAL: Realizer Refactor:** ~~Make abstract tools container-strategy aware~~ **SOLUTION: Killed the Realizer**
  - **Previous Approach**: Complex translation layer with strategy parameters
  - **New Approach**: Agents use primitive tools directly - no translation needed
  - **Result**: Clean, simple, agent-sovereign architecture
- [ ] **ðŸš¨ CRITICAL: Agent Empowerment:** Grant agents access to `Primitive` tools by default in trusted configurations
  - [ ] Update tool registration to include primitives in agent-accessible tool lists
  - [ ] Add configuration flags for primitive tool access levels
  - [ ] Implement security boundaries for primitive tool usage
- [ ] **System Prompts:** Develop comprehensive system prompts explaining the full primitive tool suite
  - [ ] Create agent onboarding documentation for container orchestration
  - [ ] Document container lifecycle patterns and best practices
  - [ ] Provide examples of complex multi-container workflows
- [ ] **Container Strategy Parameters:** Add strategy parameters to abstract tools (`ephemeral`, `session`, `task`, `service`)
- [ ] **Lifecycle Management:** Implement session-scoped and task-scoped container management
  - [ ] Session container registry (containers that live for the agent session)
  - [ ] Task container registry (containers that live for a specific task)
  - [ ] Automatic cleanup on session/task completion
  - [ ] Container sharing mechanisms between related operations
- [ ] **Resource Cleanup:** Implement intelligent cleanup for abandoned containers
  - [ ] Orphaned container detection and cleanup
  - [ ] Resource usage monitoring and limits
  - [ ] Graceful shutdown procedures for long-running containers

### Phase 8.1: Immediate Critical Fixes
- [âœ…] **ðŸ”¥ URGENT: Fix Paternalistic Realizer:** Current `writeFileTool` implementation auto-creates/destroys containers
  - **SOLUTION**: Killed the Realizer entirely - architectural bloat removed
  - **Previous**: Paternalistic translation layer that auto-managed containers for agents
  - **Now**: Agents use primitive tools directly for full sovereignty
  - **Builtin tools deprecated**: Agents must use primitive container tools for all operations
  - **Clean architecture**: No translation layer, no hidden container management
- [âœ…] **ðŸ”¥ URGENT: Enable Primitive Tool Access:** Agents currently cannot access container primitives
  - [âœ…] Added tool access validation to ExecutionEngine (prevents unauthorized tool usage)
  - [âœ…] Added helper methods to ToolRegistry for listing tools by scope and security level
  - [âœ…] Created AgentConfig helper methods for easy primitive tool access configuration:
    - `AgentConfig::with_primitive_tools()` - Full container orchestration capabilities
    - `AgentConfig::with_abstract_tools()` - High-level convenience tools only  
    - `AgentConfig::with_full_access()` - Both primitive and abstract tools
  - [âœ…] Added comprehensive system prompts explaining tool capabilities and usage patterns
- [âœ…] **ðŸ”¥ URGENT: Expose Container Lifecycle Control:** We have proper create/start separation internally, but it's hidden from agents
  - **Previous**: `createContainer` auto-started in background (agent had no control)
  - **Now**: Clean agent-controlled lifecycle: `createContainer` â†’ `startContainer`
  - **Implementation Completed**: 
    - [âœ…] Added `StartContainer` RPC to quilt.proto
    - [âœ…] Added `auto_start: bool` parameter to `CreateContainerRequest` (default: false for agent control)
    - [âœ…] Implemented `start_container` method in QuiltService client
    - [âœ…] Created `startContainer` primitive tool
    - [âœ…] Updated existing code to use explicit create â†’ start pattern

### Phase 9: Advanced Networking & Service Mesh
- [ ] **`createNetwork`**: `tools::container::network_create.rs`
- [ ] **`removeNetwork`**: `tools::container::network_remove.rs`
- [ ] **`connectToNetwork`**: `tools::container::network_connect_container.rs`
- [ ] **`disconnectFromNetwork`**: `tools::container::network_disconnect_container.rs`
- [ ] **`exposePort`**: `tools::container::port_expose.rs`
- [ ] **`bindPort`**: `tools::container::port_bind.rs`

### Phase 10: Validation & Testing
- [ ] **Integration Tests:** Comprehensive tests for all primitive tools
- [ ] **Agent Workflow Tests:** Test complex multi-container agent workflows
- [ ] **Performance Tests:** Container creation/destruction performance benchmarks
- [ ] **Security Tests:** Validate isolation and privilege boundaries
- [ ] **Cleanup Tests:** Verify proper resource cleanup in all scenarios

---

## Architectural Shift Summary

### **From Paternalistic Runtime â†’ Agent Sovereignty Platform**

**Previous Architecture (Problematic):**
- Runtime makes container lifecycle decisions for the agent
- Abstract tools automatically create/destroy containers
- Agent has no control over container persistence or reuse
- Primitive tools hidden from agents by default

**New Architecture (Agent-Centric):**
- **Agent is the sole arbiter** of all container lifecycle decisions
- Abstract tools provide **strategy parameters** for container management
- Primitive tools are the **primary interface** for agent container orchestration
- Runtime provides **secure execution platform** without imposing lifecycle assumptions

### **Critical Implementation Priorities**

1. **âœ… Fix Paternalistic Realizer** (Phase 8.1) - **COMPLETED**
   - ~~Add container strategy parameters to abstract tools~~ **SOLUTION: Killed the Realizer**
   - ~~Respect agent's container lifecycle choices~~ **SOLUTION: Agents use primitives directly**
   - ~~Enable container reuse and persistence~~ **SOLUTION: Full agent control via primitives**

2. **âœ… Enable Agent Access to Primitives** (Phase 8.1) - **COMPLETED**
   - âœ… Make primitive tools available to agents by default
   - âœ… Implement proper security boundaries
   - âœ… Provide comprehensive documentation

3. **âœ… Complete Missing Tools** (Phase 8.1) - **COMPLETED**
   - âœ… Implement missing `startContainer`
   - [ ] Add volume and image management primitives (Phase 5-6)
   - [ ] Expand networking capabilities (Phase 4, 9)

### **Agent Empowerment Examples**

**Complex Workflow Scenario:**
```
Agent Task: "Set up a development environment with database and web server"

Agent Strategy (with primitives):
1. createContainer(image: "postgres:15", name: "dev-db") 
2. createContainer(image: "node:18", name: "dev-web")
3. establishConnection(from: "dev-web", to: "dev-db", port: 5432)
4. execInContainer("dev-db", ["createdb", "myapp"])
5. execInContainer("dev-web", ["npm", "start"])
6. [containers persist for entire development session]
7. [agent manages cleanup when done]
```

**vs Current Paternalistic Approach:**
```
Agent uses abstract tools â†’ Runtime auto-creates/destroys containers
â†’ No persistence, no state sharing, no complex workflows possible
```

### **Success Metrics**

- [ ] Agent can maintain long-running service containers
- [ ] Agent can build complex multi-container applications  
- [ ] Agent can implement custom container lifecycle strategies
- [ ] Agent has full visibility and control over container resources
- [ ] Runtime never makes container decisions without agent input 