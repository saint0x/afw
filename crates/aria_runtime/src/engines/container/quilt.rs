use std::collections::HashMap;
use tonic::transport::{Channel, Endpoint, Uri};
use tower::service_fn;
use hyper_util::rt::TokioIo;
use crate::engines::config::QuiltConfig;
use crate::errors::{AriaError, AriaResult, ErrorCategory, ErrorCode, ErrorSeverity};
use crate::types::{ContainerExecutionResult, ContainerState, ContainerStatus, ResourceUsage};

// This module will be generated by `tonic-build` in `build.rs`
pub mod quilt_proto {
    tonic::include_proto!("quilt");
}

use quilt_proto::quilt_service_client::QuiltServiceClient;
use quilt_proto::{
    CreateContainerRequest, StartContainerRequest, ExecContainerRequest, GetContainerLogsRequest,
    GetContainerStatusRequest, RemoveContainerRequest, StopContainerRequest,
    LogEntry, ListContainersRequest, GetSystemMetricsRequest, GetNetworkTopologyRequest,
    GetContainerNetworkInfoRequest, ExecContainerAsyncRequest, GetTaskStatusRequest,
    GetTaskResultRequest, ListTasksRequest, CancelTaskRequest,
};

/// A client for interacting with the `quiltd` container management daemon.
///
/// This service acts as a high-level wrapper around the gRPC client,
/// providing a convenient API for the Aria runtime to manage container lifecycles.
#[derive(Clone)]
pub struct QuiltService {
    client: QuiltServiceClient<Channel>,
}

impl QuiltService {
    /// Creates a new `QuiltService` and connects to the `quiltd` daemon via Unix socket.
    pub async fn new(config: &QuiltConfig) -> Result<Self, tonic::transport::Error> {
        // Clone the socket path to avoid lifetime issues
        let socket_path = config.socket_path.clone();
        
        // Create a channel that connects to the Unix socket
        let channel = Endpoint::try_from("http://[::]:50051")?
            .connect_with_connector(service_fn(move |_: Uri| {
                let socket_path = socket_path.clone();
                async move {
                    let unix_stream = tokio::net::UnixStream::connect(socket_path).await?;
                    Ok::<_, std::io::Error>(TokioIo::new(unix_stream))
                }
            }))
            .await?;

        let client = QuiltServiceClient::new(channel);
        Ok(Self { client })
    }

    /// Creates a new container (agent must explicitly start it).
    pub async fn create_container(
        &mut self,
        image_path: String,
        command: Vec<String>,
        env: HashMap<String, String>,
    ) -> AriaResult<String> {
        let request = CreateContainerRequest {
            image_path,
            command,
            environment: env,
            auto_start: false, // Agent must explicitly start
            ..Default::default()
        };

        let response = self.client.create_container(request).await.map_err(to_aria_error)?;
        let res = response.into_inner();

        if res.success {
            Ok(res.container_id)
        } else {
            Err(AriaError::new(
                ErrorCode::ContainerOperationFailed,
                ErrorCategory::Container,
                ErrorSeverity::High,
                &format!("Failed to create container: {}", res.error_message),
            ))
        }
    }

    /// Starts a created container.
    pub async fn start_container(&mut self, container_id: String) -> AriaResult<()> {
        let request = StartContainerRequest { container_id };
        let response = self.client.start_container(request).await.map_err(to_aria_error)?;
        let res = response.into_inner();

        if res.success {
            Ok(())
        } else {
            Err(AriaError::new(
                ErrorCode::ContainerOperationFailed,
                ErrorCategory::Container,
                ErrorSeverity::High,
                &format!("Failed to start container: {}", res.error_message),
            ))
        }
    }

    /// Stops a running container.
    pub async fn stop_container(&mut self, container_id: String) -> AriaResult<()> {
        let request = StopContainerRequest { container_id, timeout_seconds: 10 };
        let response = self.client.stop_container(request).await.map_err(to_aria_error)?;
        let res = response.into_inner();

        if res.success {
            Ok(())
        } else {
            Err(AriaError::new(
                ErrorCode::ContainerOperationFailed,
                ErrorCategory::Container,
                ErrorSeverity::High,
                &format!("Failed to stop container: {}", res.error_message),
            ))
        }
    }

    /// Removes a container.
    pub async fn remove_container(&mut self, container_id: String) -> AriaResult<()> {
        let request = RemoveContainerRequest {
            container_id,
            force: true, // Always force removal for runtime cleanup
        };
        let response = self.client.remove_container(request).await.map_err(to_aria_error)?;
        let res = response.into_inner();

        if res.success {
            Ok(())
        } else {
            Err(AriaError::new(
                ErrorCode::ContainerOperationFailed,
                ErrorCategory::Container,
                ErrorSeverity::High,
                &format!("Failed to remove container: {}", res.error_message),
            ))
        }
    }

    /// Executes a command inside a running container.
    pub async fn exec_in_container(
        &mut self,
        container_id: String,
        command: Vec<String>,
    ) -> AriaResult<ContainerExecutionResult> {
        let request = ExecContainerRequest {
            container_id,
            command,
            capture_output: true,
            ..Default::default()
        };

        let response = self.client.exec_container(request).await.map_err(to_aria_error)?;
        let res = response.into_inner();

        if res.success {
            Ok(ContainerExecutionResult {
                exit_code: res.exit_code,
                stdout: res.stdout,
                stderr: res.stderr,
                execution_time_ms: 0, // Not provided by this gRPC call
                resource_usage: None,
            })
        } else {
            Err(AriaError::new(
                ErrorCode::ContainerOperationFailed,
                ErrorCategory::Container,
                ErrorSeverity::High,
                &res.error_message,
            ))
        }
    }

    /// Retrieves the status of a container.
    pub async fn get_container_status(&mut self, container_id: String) -> AriaResult<ContainerStatus> {
        let request = GetContainerStatusRequest { container_id };
        let response = self.client.get_container_status(request).await.map_err(to_aria_error)?;
        let res = response.into_inner();
        let status_enum = quilt_proto::ContainerStatus::from_i32(res.status).unwrap_or_default();

        let state = match status_enum {
            quilt_proto::ContainerStatus::Pending => ContainerState::Created,
            quilt_proto::ContainerStatus::Running => ContainerState::Running,
            quilt_proto::ContainerStatus::Exited => ContainerState::Exited,
            quilt_proto::ContainerStatus::Failed => ContainerState::Failed,
            quilt_proto::ContainerStatus::Unspecified => ContainerState::Failed,
        };

        Ok(ContainerStatus {
            id: res.container_id,
            state,
            created_at: res.created_at,
            started_at: None, // Not provided by quiltd
            finished_at: None, // Not provided by quiltd
            exit_code: Some(res.exit_code),
            resource_usage: Some(ResourceUsage {
                cpu_time_ms: 0, // Not provided by quiltd
                memory_peak_mb: res.memory_usage_bytes / (1024 * 1024),
                disk_io_mb: 0, // Not provided
                network_io_kb: 0, // Not provided
            }),
        })
    }

    /// Retrieves logs from a container.
    pub async fn get_container_logs(&mut self, container_id: String) -> AriaResult<String> {
        let request = GetContainerLogsRequest { container_id };
        let response = self.client.get_container_logs(request).await.map_err(to_aria_error)?;
        let logs: Vec<String> = response.into_inner().logs.into_iter().map(|log: LogEntry| log.message).collect();
        Ok(logs.join("\n"))
    }

    pub async fn list_containers(&mut self) -> AriaResult<Vec<quilt_proto::ContainerInfo>> {
        let request = ListContainersRequest {
            state_filter: quilt_proto::ContainerStatus::Unspecified.into(),
        };
        let response = self.client.list_containers(request).await.map_err(to_aria_error)?;
        Ok(response.into_inner().containers)
    }

    pub async fn get_system_metrics(&mut self) -> AriaResult<quilt_proto::GetSystemMetricsResponse> {
        let request = GetSystemMetricsRequest {};
        let response = self.client.get_system_metrics(request).await.map_err(to_aria_error)?;
        Ok(response.into_inner())
    }

    pub async fn get_network_topology(&mut self) -> AriaResult<Vec<quilt_proto::NetworkNode>> {
        let request = GetNetworkTopologyRequest {};
        let response = self.client.get_network_topology(request).await.map_err(to_aria_error)?;
        Ok(response.into_inner().nodes)
    }

    pub async fn get_container_network_info(&mut self, container_id: String) -> AriaResult<quilt_proto::GetContainerNetworkInfoResponse> {
        let request = GetContainerNetworkInfoRequest { container_id };
        let response = self.client.get_container_network_info(request).await.map_err(to_aria_error)?;
        Ok(response.into_inner())
    }

    // === Async Task Management ===

    /// Execute a command asynchronously in a container
    pub async fn exec_container_async(
        &mut self,
        container_id: String,
        command: Vec<String>,
        timeout_seconds: Option<i32>,
    ) -> AriaResult<String> {
        let request = quilt_proto::ExecContainerAsyncRequest {
            container_id,
            command,
            working_directory: "".to_string(),
            environment: std::collections::HashMap::new(),
            capture_output: true,
            timeout_seconds: timeout_seconds.unwrap_or(0),
        };

        let response = self.client.exec_container_async(request).await.map_err(to_aria_error)?;
        let res = response.into_inner();

        if res.success {
            Ok(res.task_id)
        } else {
            Err(AriaError::new(
                ErrorCode::ContainerOperationFailed,
                ErrorCategory::Container,
                ErrorSeverity::High,
                &format!("Failed to start async task: {}", res.error_message),
            ))
        }
    }

    /// Get the status of an async task
    pub async fn get_task_status(&mut self, task_id: String) -> AriaResult<quilt_proto::GetTaskStatusResponse> {
        let request = quilt_proto::GetTaskStatusRequest { task_id };
        let response = self.client.get_task_status(request).await.map_err(to_aria_error)?;
        Ok(response.into_inner())
    }

    /// Get the result of a completed async task
    pub async fn get_task_result(&mut self, task_id: String) -> AriaResult<quilt_proto::GetTaskResultResponse> {
        let request = quilt_proto::GetTaskResultRequest { task_id };
        let response = self.client.get_task_result(request).await.map_err(to_aria_error)?;
        Ok(response.into_inner())
    }

    /// List tasks for a container
    pub async fn list_tasks(&mut self, container_id: String, status_filter: Option<quilt_proto::TaskStatus>) -> AriaResult<Vec<quilt_proto::TaskInfo>> {
        let request = quilt_proto::ListTasksRequest {
            container_id,
            status_filter: status_filter.unwrap_or(quilt_proto::TaskStatus::TaskUnspecified) as i32,
        };
        let response = self.client.list_tasks(request).await.map_err(to_aria_error)?;
        Ok(response.into_inner().tasks)
    }

    /// Cancel a running async task
    pub async fn cancel_task(&mut self, task_id: String) -> AriaResult<bool> {
        let request = quilt_proto::CancelTaskRequest { task_id };
        let response = self.client.cancel_task(request).await.map_err(to_aria_error)?;
        let res = response.into_inner();
        
        if res.success {
            Ok(true)
        } else {
            Err(AriaError::new(
                ErrorCode::ContainerOperationFailed,
                ErrorCategory::Container,
                ErrorSeverity::Medium,
                &format!("Failed to cancel task: {}", res.error_message),
            ))
        }
    }

    /// Upload a bundle via streaming
    pub async fn upload_bundle<S>(&mut self, stream: S) -> AriaResult<quilt_proto::UploadBundleResponse>
    where
        S: tonic::codegen::tokio_stream::Stream<Item = Result<quilt_proto::UploadBundleRequest, tonic::Status>> + Send + 'static,
    {
        let response = self.client.upload_bundle(stream).await.map_err(to_aria_error)?;
        Ok(response.into_inner())
    }
}

/// Helper function to convert tonic::Status to AriaError
fn to_aria_error(status: tonic::Status) -> AriaError {
    AriaError::new(
        ErrorCode::UpstreamServiceError,
        ErrorCategory::Network,
        ErrorSeverity::High,
        &format!("gRPC call to quiltd failed: {}", status.message()),
    )
}
