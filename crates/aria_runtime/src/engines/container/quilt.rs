use std::collections::HashMap;
use tonic::transport::Channel;
use crate::engines::config::QuiltConfig;
use crate::errors::{AriaError, AriaResult, ErrorCategory, ErrorCode, ErrorSeverity};
use crate::types::{ContainerExecutionResult, ContainerState, ContainerStatus, ResourceUsage};

// This module will be generated by `tonic-build` in `build.rs`
pub mod quilt_proto {
    tonic::include_proto!("quilt");
}

use quilt_proto::quilt_service_client::QuiltServiceClient;
use quilt_proto::{
    CreateContainerRequest, ExecContainerRequest, GetContainerLogsRequest,
    GetContainerStatusRequest, RemoveContainerRequest, StopContainerRequest,
    LogEntry,
};

/// A client for interacting with the `quiltd` container management daemon.
///
/// This service acts as a high-level wrapper around the gRPC client,
/// providing a convenient API for the Aria runtime to manage container lifecycles.
#[derive(Clone)]
pub struct QuiltService {
    client: QuiltServiceClient<Channel>,
}

impl QuiltService {
    /// Creates a new `QuiltService` and connects to the `quiltd` daemon.
    pub async fn new(config: &QuiltConfig) -> Result<Self, tonic::transport::Error> {
        let client = QuiltServiceClient::connect(config.endpoint.clone()).await?;
        Ok(Self { client })
    }

    /// Creates a new container.
    pub async fn create_container(
        &mut self,
        image_path: String,
        command: Vec<String>,
        env: HashMap<String, String>,
    ) -> AriaResult<String> {
        let request = CreateContainerRequest {
            image_path,
            command,
            environment: env,
            ..Default::default()
        };

        let response = self.client.create_container(request).await.map_err(to_aria_error)?;
        let res = response.into_inner();

        if res.success {
            Ok(res.container_id)
        } else {
            Err(AriaError::new(
                ErrorCode::ContainerOperationFailed,
                ErrorCategory::Container,
                ErrorSeverity::High,
                &format!("Failed to create container: {}", res.error_message),
            ))
        }
    }

    /// Stops a running container.
    pub async fn stop_container(&mut self, container_id: String) -> AriaResult<()> {
        let request = StopContainerRequest { container_id, timeout_seconds: 10 };
        let response = self.client.stop_container(request).await.map_err(to_aria_error)?;
        let res = response.into_inner();

        if res.success {
            Ok(())
        } else {
            Err(AriaError::new(
                ErrorCode::ContainerOperationFailed,
                ErrorCategory::Container,
                ErrorSeverity::High,
                &format!("Failed to stop container: {}", res.error_message),
            ))
        }
    }

    /// Removes a container.
    pub async fn remove_container(&mut self, container_id: String) -> AriaResult<()> {
        let request = RemoveContainerRequest {
            container_id,
            force: true, // Always force removal for runtime cleanup
        };
        let response = self.client.remove_container(request).await.map_err(to_aria_error)?;
        let res = response.into_inner();

        if res.success {
            Ok(())
        } else {
            Err(AriaError::new(
                ErrorCode::ContainerOperationFailed,
                ErrorCategory::Container,
                ErrorSeverity::High,
                &format!("Failed to remove container: {}", res.error_message),
            ))
        }
    }

    /// Executes a command inside a running container.
    pub async fn exec_in_container(
        &mut self,
        container_id: String,
        command: Vec<String>,
    ) -> AriaResult<ContainerExecutionResult> {
        let request = ExecContainerRequest {
            container_id,
            command,
            capture_output: true,
            ..Default::default()
        };

        let response = self.client.exec_container(request).await.map_err(to_aria_error)?;
        let res = response.into_inner();

        if res.success {
            Ok(ContainerExecutionResult {
                exit_code: res.exit_code,
                stdout: res.stdout,
                stderr: res.stderr,
                execution_time_ms: 0, // Not provided by this gRPC call
                resource_usage: None,
            })
        } else {
            Err(AriaError::new(
                ErrorCode::ContainerOperationFailed,
                ErrorCategory::Container,
                ErrorSeverity::High,
                &res.error_message,
            ))
        }
    }

    /// Retrieves the status of a container.
    pub async fn get_container_status(&mut self, container_id: String) -> AriaResult<ContainerStatus> {
        let request = GetContainerStatusRequest { container_id };
        let response = self.client.get_container_status(request).await.map_err(to_aria_error)?;
        let res = response.into_inner();
        let status_enum = quilt_proto::ContainerStatus::from_i32(res.status).unwrap_or_default();

        let state = match status_enum {
            quilt_proto::ContainerStatus::Pending => ContainerState::Created,
            quilt_proto::ContainerStatus::Running => ContainerState::Running,
            quilt_proto::ContainerStatus::Exited => ContainerState::Exited,
            quilt_proto::ContainerStatus::Failed => ContainerState::Failed,
        };

        Ok(ContainerStatus {
            id: res.container_id,
            state,
            created_at: res.created_at,
            started_at: None, // Not provided by quiltd
            finished_at: None, // Not provided by quiltd
            exit_code: Some(res.exit_code),
            resource_usage: Some(ResourceUsage {
                cpu_time_ms: 0, // Not provided by quiltd
                memory_peak_mb: res.memory_usage_bytes / (1024 * 1024),
                disk_io_mb: 0, // Not provided
                network_io_kb: 0, // Not provided
            }),
        })
    }

    /// Retrieves logs from a container.
    pub async fn get_container_logs(&mut self, container_id: String) -> AriaResult<String> {
        let request = GetContainerLogsRequest { container_id };
        let response = self.client.get_container_logs(request).await.map_err(to_aria_error)?;
        let logs: Vec<String> = response.into_inner().logs.into_iter().map(|log: LogEntry| log.message).collect();
        Ok(logs.join("\n"))
    }
}

/// Helper function to convert tonic::Status to AriaError
fn to_aria_error(status: tonic::Status) -> AriaError {
    AriaError::new(
        ErrorCode::UpstreamServiceError,
        ErrorCategory::Network,
        ErrorSeverity::High,
        &format!("gRPC call to quiltd failed: {}", status.message()),
    )
}
