# Jockey Image

Generated: 06-17-2025 at 18:42:29

## Repository Structure

```
cache
│   ├── tree-builder.ts
│   ├── utils
│   │   ├── ExecutionAnalyzer.ts
│       └── TaskAnalyzer.ts
│   ├── index.ts
│   ├── map-processor.ts
│   ├── context-tree.json
│   ├── command-map.xml
│   ├── service.ts
    └── context-api.ts
```

## File: /Users/deepsaint/Desktop/symphony-sdk/src/cache/map-processor.ts

```ts
import { parseString } from 'xml2js';
import { promisify } from 'util';
import { readFileSync } from 'fs';
import { Logger } from '../utils/logger';
import { IDatabaseService } from '../db/IDatabaseService';
import { ValidationError } from '../errors/index';

const parseXMLAsync = promisify(parseString);

// ==========================================
// TYPE DEFINITIONS
// ==========================================

export interface Variable {
    name: string;
    position: number;
    type: string;
    description: string;
    validation?: {
        allowedValues?: string[];
        pattern?: string;
        minLength?: number;
        maxLength?: number;
    };
}

export interface Pattern {
    id: string;
    groupType: string;
    confidence: number;
    trigger: string;
    variables: Variable[];
    examples: string[];
    toolName: string;
    parameters: Record<string, string>;
    usageStats: {
        successCount: number;
        failureCount: number;
        lastUsed?: Date;
        averageLatency: number;
    };
}

export interface PatternMatch {
    pattern: Pattern;
    confidence: number;
    extractedVariables: Record<string, any>;
    toolCall: {
        name: string;
        parameters: Record<string, any>;
    };
}

export interface CacheResult {
    matched: boolean;
    confidence: number;
    patternMatch?: PatternMatch;
    shouldUseFastPath: boolean;
    executionTime: number;
}

export interface RuntimeToolCallDetails {
    name: string;
    parameters: Record<string, any>;
    confidence?: number;
    source?: string; // Optional: to track where this runtime pattern originated
}

// ==========================================
// COMMAND MAP PROCESSOR
// ==========================================

export class CommandMapProcessor {
    private static instance: CommandMapProcessor;
    private patterns: Map<string, Pattern> = new Map();
    private logger: Logger;
    private database: IDatabaseService;
    private fastPathThreshold: number = 0.85;
    private initialized: boolean = false;
    private dbPatternsLoaded: boolean = false;

    private constructor(database: IDatabaseService) {
        this.logger = Logger.getInstance('CommandMapProcessor');
        this.database = database;
    }

    static getInstance(database: IDatabaseService): CommandMapProcessor {
        if (!CommandMapProcessor.instance) {
            CommandMapProcessor.instance = new CommandMapProcessor(database);
        } else if (CommandMapProcessor.instance.database !== database) {
            // If a different database is provided, update the instance
            CommandMapProcessor.instance.logger.info('CommandMapProcessor', 'Updating database reference');
            CommandMapProcessor.instance.database = database;
            CommandMapProcessor.instance.initialized = false; // Force re-initialization
        }
        return CommandMapProcessor.instance;
    }

    async initialize(xmlPath?: string): Promise<void> {
        if (this.initialized) return;

        this.logger.info('CommandMapProcessor', 'Initializing command map processor');

        try {
            // Load patterns from XML file
            if (xmlPath) {
                await this.loadPatternsFromXML(xmlPath);
            }

            // DB patterns will be loaded on demand.
            this.initialized = true;
            this.logger.info('CommandMapProcessor', `Initialized with ${this.patterns.size} XML patterns. DB patterns will be loaded on demand.`);
        } catch (error) {
            this.logger.error('CommandMapProcessor', 'Failed to initialize', { error });
            throw error;
        }
    }

    private async loadPatternsFromXML(xmlPath: string): Promise<void> {
        this.logger.info('CommandMapProcessor', `Loading patterns from XML: ${xmlPath}`);

        const xmlContent = readFileSync(xmlPath, 'utf-8');
        const parsed = await parseXMLAsync(xmlContent) as any;

        const commandMap = parsed.CommandMap;
        if (!commandMap || !commandMap.PatternGroup) {
            throw new ValidationError(
                'Invalid command map XML structure',
                { xmlStructure: parsed },
                { component: 'MapProcessor', operation: 'parseCommandMapXML' }
            );
        }

        for (const group of commandMap.PatternGroup) {
            const groupType = group.$.type;
            
            if (!group.Pattern) continue;

            for (const patternData of group.Pattern) {
                const pattern = this.parseXMLPattern(patternData, groupType);
                this.patterns.set(pattern.id, pattern);

                // Save to database
                await this.savePatternToDatabase(pattern);
            }
        }
    }

    private parseXMLPattern(patternData: any, groupType: string): Pattern {
        const linguistic = patternData.Linguistic[0];
        const toolMapping = patternData.ToolMapping[0];
        const usageStats = patternData.UsageStats[0];

        // Parse variables
        const variables: Variable[] = [];
        if (linguistic.Variables?.[0]?.Variable) {
            for (const varData of linguistic.Variables[0].Variable) {
                variables.push({
                    name: varData.$.name,
                    position: parseInt(varData.$.position),
                    type: varData.Type[0],
                    description: varData.Description[0],
                    validation: varData.Validation?.[0] ? {
                        allowedValues: varData.Validation[0].AllowedValues?.[0]?.Value || undefined
                    } : undefined
                });
            }
        }

        // Parse tool parameters
        const parameters: Record<string, string> = {};
        if (toolMapping.Parameters?.[0]?.Parameter) {
            for (const param of toolMapping.Parameters[0].Parameter) {
                parameters[param.$.name] = param.$.value;
            }
        }

        return {
            id: patternData.$.id,
            groupType,
            confidence: parseFloat(patternData.$.confidence),
            trigger: linguistic.Trigger[0],
            variables,
            examples: linguistic.Examples?.[0]?.Example || [],
            toolName: toolMapping.Tool[0],
            parameters,
            usageStats: {
                successCount: parseInt(usageStats.SuccessCount[0]),
                failureCount: parseInt(usageStats.FailureCount[0]),
                lastUsed: usageStats.LastUsed ? new Date(usageStats.LastUsed[0]) : undefined,
                averageLatency: parseInt(usageStats.AverageLatency[0].replace('ms', ''))
            }
        };
    }

    private async savePatternToDatabase(pattern: Pattern): Promise<void> {
        try {
            // Check if pattern with this ID already exists
            const existingPatternInDB = await this.database.getNlpPatternRecordById(pattern.id);

            if (!existingPatternInDB) {
                this.logger.info('CommandMapProcessor', `Saving new pattern to DB: ${pattern.id}`)
                await this.database.saveNlpPatternRecord({
                    id: pattern.id,
                    toolName: pattern.toolName,
                    nlpPattern: pattern.trigger,
                    source: pattern.groupType,
                    createdAt: new Date(),
                    updatedAt: new Date()
                });
            } else {
                // Pattern already exists in DB
                this.logger.debug('CommandMapProcessor', `Pattern ${pattern.id} already exists in DB, not re-saving.`);
            }
        } catch (error) {
            this.logger.error('CommandMapProcessor', `Failed to save pattern ${pattern.id} to database`, { error });
            // Decide if this should throw
        }
    }

    private async ensureDbPatternsLoaded(): Promise<void> {
        if (this.dbPatternsLoaded) return;
        try {
            this.logger.info('CommandMapProcessor', 'Lazily loading patterns from database');
            await this.loadPatternsFromDatabase();
            this.dbPatternsLoaded = true;
            this.logger.info('CommandMapProcessor', `DB patterns loaded. Total patterns: ${this.patterns.size}`);
        } catch (error) {
            this.logger.error('CommandMapProcessor', 'Failed to lazily load patterns from database', { error });
            // Optionally re-throw or handle so the calling function knows about the failure
            throw error;
        }
    }

    private async loadPatternsFromDatabase(): Promise<void> {
        this.logger.info('CommandMapProcessor', 'Loading patterns from database');

        // Use the comprehensive database interface to load all NLP patterns
        try {
            const dbPatterns = await this.database.getAllNlpPatternRecords({ isActive: true });
            
            for (const dbPattern of dbPatterns) {
                if (this.patterns.has(dbPattern.id)) {
                    // Update existing pattern with database stats
                    // Convert from StoredNlpPattern format if needed
                    this.logger.debug('CommandMapProcessor', `Updated pattern ${dbPattern.id} from database`);
                }
            }
        } catch (error) {
            this.logger.warn('CommandMapProcessor', 'Could not load NLP patterns from database', { error });
        }
    }

    async processUserInput(input: string, sessionId?: string): Promise<CacheResult> {
        await this.ensureDbPatternsLoaded();
        const startTime = Date.now();
        
        this.logger.info('CommandMapProcessor', 'Processing user input for pattern match', {
            input: input.substring(0, 100),
            sessionId
        });

        try {
            const match = await this.findBestPattern(input);
            const executionTime = Date.now() - startTime;

            if (match) {
                const shouldUseFastPath = match.confidence >= this.fastPathThreshold;
                
                // Record the pattern match attempt
                if (sessionId) {
                    await this.recordPatternAttempt(match.pattern.id, input, match.extractedVariables, sessionId);
                }

                return {
                    matched: true,
                    confidence: match.confidence,
                    patternMatch: match,
                    shouldUseFastPath,
                    executionTime
                };
            }

            return {
                matched: false,
                confidence: 0,
                shouldUseFastPath: false,
                executionTime
            };
        } catch (error) {
            this.logger.error('CommandMapProcessor', 'Failed to process user input', { error, input });
            return {
                matched: false,
                confidence: 0,
                shouldUseFastPath: false,
                executionTime: Date.now() - startTime
            };
        }
    }

    private async findBestPattern(input: string): Promise<PatternMatch | null> {
        let bestMatch: PatternMatch | null = null;
        let bestScore = 0;

        for (const pattern of this.patterns.values()) {
            const match = this.matchPattern(input, pattern);
            if (match && match.confidence > bestScore) {
                bestMatch = match;
                bestScore = match.confidence;
            }
        }

        return bestMatch;
    }

    private matchPattern(input: string, pattern: Pattern): PatternMatch | null {
        // Convert trigger pattern to regex
        // "search for * in *" becomes /search for (.*?) in (.*)/i
        const triggerRegex = this.buildTriggerRegex(pattern.trigger);
        const match = input.toLowerCase().match(triggerRegex);

        if (!match) return null;

        // Extract variables
        const extractedVariables = this.extractVariables(match, pattern.variables);
        
        // Calculate confidence based on pattern confidence + match quality
        let confidence = pattern.confidence;
        
        // Adjust confidence based on variable extraction quality
        const variableScore = this.calculateVariableScore(extractedVariables, pattern.variables);
        confidence = confidence * variableScore;

        // Build tool call parameters
        const toolCall = this.buildToolCall(pattern, extractedVariables);

        return {
            pattern,
            confidence,
            extractedVariables,
            toolCall
        };
    }

    private buildTriggerRegex(trigger: string): RegExp {
        // Escape special regex characters except *
        const escaped = trigger.replace(/[.+?^${}()|[\]\\]/g, '\\$&');
        
        // Replace * with capture groups
        const regexPattern = escaped.replace(/\*/g, '(.*?)');
        
        return new RegExp(`^${regexPattern}$`, 'i');
    }

    private extractVariables(match: RegExpMatchArray, variables: Variable[]): Record<string, any> {
        const extracted: Record<string, any> = {};
        
        // Skip the full match and extract captured groups
        for (let i = 1; i < match.length && i - 1 < variables.length; i++) {
            const variable = variables[i - 1];
            const value = match[i].trim();
            
            extracted[variable.name] = this.castVariable(value, variable.type);
        }

        return extracted;
    }

    private castVariable(value: string, type: string): any {
        switch (type.toLowerCase()) {
            case 'number':
                const num = parseInt(value);
                return isNaN(num) ? value : num;
            case 'boolean':
                return value.toLowerCase() === 'true' || value.toLowerCase() === 'yes';
            case 'array':
                return value.split(',').map(s => s.trim());
            default:
                return value;
        }
    }

    private calculateVariableScore(extracted: Record<string, any>, variables: Variable[]): number {
        if (variables.length === 0) return 1.0;

        let score = 0;
        for (const variable of variables) {
            const value = extracted[variable.name];
            if (value !== undefined && value !== '') {
                score += 1;
                
                // Bonus for validation compliance
                if (this.validateVariable(value, variable)) {
                    score += 0.1;
                }
            }
        }

        return Math.min(1.0, score / variables.length);
    }

    private validateVariable(value: any, variable: Variable): boolean {
        if (!variable.validation) return true;

        const validation = variable.validation;
        
        if (validation.allowedValues && !validation.allowedValues.includes(value)) {
            return false;
        }
        
        if (typeof value === 'string') {
            if (validation.minLength && value.length < validation.minLength) return false;
            if (validation.maxLength && value.length > validation.maxLength) return false;
            if (validation.pattern && !new RegExp(validation.pattern).test(value)) return false;
        }

        return true;
    }

    private buildToolCall(pattern: Pattern, variables: Record<string, any>): { name: string; parameters: Record<string, any> } {
        const parameters: Record<string, any> = {};

        for (const [paramName, paramTemplate] of Object.entries(pattern.parameters)) {
            parameters[paramName] = this.interpolateParameter(paramTemplate as string, variables);
        }

        return {
            name: pattern.toolName,
            parameters
        };
    }

    private interpolateParameter(template: string, variables: Record<string, any>): any {
        // Handle simple variable substitution: ${variableName}
        let result = template.replace(/\${(\w+)}/g, (match, varName) => {
            return variables[varName]?.toString() || match;
        });

        // Handle array conversion: [${target}]
        if (result.startsWith('[') && result.endsWith(']')) {
            const inner = result.slice(1, -1);
            if (variables[inner]) {
                return Array.isArray(variables[inner]) ? variables[inner] : [variables[inner]];
            }
        }

        // Handle boolean expressions: ${background == 'background'}
        const boolMatch = result.match(/\${(\w+)\s*==\s*'([^']+)'}/);
        if (boolMatch) {
            return variables[boolMatch[1]] === boolMatch[2];
        }

        // Try to parse as JSON for complex objects
        if (result.startsWith('{') || result.startsWith('[')) {
            try {
                return JSON.parse(result);
            } catch {
                // Fall back to string
            }
        }

        return result;
    }

    private async recordPatternAttempt(
        patternId: string, 
        input: string, 
        variables: Record<string, any>, 
        sessionId: string
    ): Promise<void> {
        try {
            // Record tool execution using the comprehensive database interface
            await this.database.recordToolExecution({
                execution_id: `pattern_attempt_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`,
                tool_name: 'pattern_matcher',
                session_id: sessionId,
                parameters: JSON.stringify({ patternId, input: input.substring(0, 100), variables }),
                result: JSON.stringify({ status: 'attempted', patternId }),
                success: true,
                execution_time_ms: 0 // Will be updated after actual tool execution
            });
        } catch (error) {
            this.logger.error('CommandMapProcessor', 'Failed to record pattern attempt', { error, patternId });
        }
    }

    async updatePatternConfidence(patternId: string, success: boolean, executionTime: number): Promise<void> {
        try {
            await this.ensureDbPatternsLoaded();
            const pattern = this.patterns.get(patternId);
            if (!pattern) return;

            // Update local pattern stats
            if (success) {
                pattern.usageStats.successCount++;
            } else {
                pattern.usageStats.failureCount++;
            }
            
            pattern.usageStats.lastUsed = new Date();
            
            // Update average latency (moving average)
            const totalExecutions = pattern.usageStats.successCount + pattern.usageStats.failureCount;
            pattern.usageStats.averageLatency = 
                ((pattern.usageStats.averageLatency * (totalExecutions - 1)) + executionTime) / totalExecutions;

            // Recalculate confidence based on success rate
            const successRate = pattern.usageStats.successCount / totalExecutions;
            const newConfidence = Math.min(0.99, Math.max(0.1, successRate * pattern.confidence));
            pattern.confidence = newConfidence;

            // Update database using updateNlpPatternRecord
            try {
                await this.database.updateNlpPatternRecord(patternId, {
                    // Can only update properties that exist in StoredNlpPattern
                    isActive: true // Keep pattern active
                });
            } catch (dbError) {
                this.logger.warn('CommandMapProcessor', 'Failed to update pattern in database', { patternId, dbError });
            }

            this.logger.info('CommandMapProcessor', `Updated pattern confidence`, {
                patternId,
                newConfidence: newConfidence.toFixed(3),
                successRate: (successRate * 100).toFixed(1) + '%',
                totalExecutions
            });
        } catch (error) {
            this.logger.error('CommandMapProcessor', 'Failed to update pattern confidence', { error, patternId });
        }
    }

    async getPatterns(): Promise<Pattern[]> {
        await this.ensureDbPatternsLoaded();
        return Array.from(this.patterns.values());
    }

    /**
     * Adds a runtime-generated NLP pattern to the in-memory command map.
     * Does NOT persist the pattern to the database.
     * @param nlpPattern The natural language pattern string.
     * @param toolCallDetails Details of the tool call associated with this pattern.
     * @returns The created Pattern object, or null if creation failed.
     */
    public addRuntimePatternToMemory(nlpPattern: string, toolCallDetails: RuntimeToolCallDetails): Pattern | null {
        try {
            this.logger.info('CommandMapProcessor', 'Adding runtime pattern to memory', {
                nlpPattern: nlpPattern.substring(0, 50) + '...',
                toolName: toolCallDetails.name,
                source: toolCallDetails.source
            });

            const patternId = `runtime_${toolCallDetails.name}_${Date.now()}_${Math.random().toString(36).substring(2, 7)}`;
            
            const pattern: Pattern = {
                id: patternId,
                groupType: toolCallDetails.source || 'runtime_memory',
                confidence: toolCallDetails.confidence || 0.75, // Slightly higher default for runtime if actively added
                trigger: nlpPattern,
                variables: this.extractVariablesFromNLP(nlpPattern),
                examples: [nlpPattern], // Basic example
                toolName: toolCallDetails.name,
                parameters: toolCallDetails.parameters as Record<string, string>,
                usageStats: {
                    successCount: 0,
                    failureCount: 0,
                    lastUsed: new Date(), // Mark as used recently
                    averageLatency: 0
                }
            };

            this.patterns.set(patternId, pattern);
            this.logger.info('CommandMapProcessor', 'Runtime pattern added to memory successfully', {
                patternId,
                toolName: toolCallDetails.name
            });
            return pattern;
        } catch (error) {
            this.logger.error('CommandMapProcessor', 'Failed to add runtime pattern to memory', { 
                error, 
                nlpPattern, 
                toolName: toolCallDetails.name 
            });
            return null;
        }
    }

    /**
     * Persists a given runtime pattern (previously added to memory) to the database.
     * @param patternToPersist The Pattern object to save.
     */
    public async persistRuntimePattern(patternToPersist: Pattern): Promise<void> {
        if (!patternToPersist) {
            this.logger.warn('CommandMapProcessor', 'Attempted to persist a null/undefined pattern. Skipping.');
            return;
        }
        try {
            this.logger.info('CommandMapProcessor', 'Persisting runtime pattern to database', {
                patternId: patternToPersist.id,
                toolName: patternToPersist.toolName
            });
            await this.savePatternToDatabase(patternToPersist);
            this.logger.info('CommandMapProcessor', 'Runtime pattern persisted to database successfully', {
                patternId: patternToPersist.id
            });
        } catch (error) {
            this.logger.error('CommandMapProcessor', 'Failed to persist runtime pattern to database', { 
                error, 
                patternId: patternToPersist.id
            });
            // Decide if this should re-throw
        }
    }

    /**
     * RENAMED & REFACTORED from old addRuntimePattern.
     * Adds a runtime-generated NLP pattern to memory AND persists it to the database.
     * @param nlpPattern The natural language pattern string.
     * @param toolCallDetails Details of the tool call associated with this pattern.
     * @returns The created Pattern object if successful, otherwise null.
     */
    async addAndPersistRuntimePattern(nlpPattern: string, toolCallDetails: RuntimeToolCallDetails): Promise<Pattern | null> {
        const patternInMemory = this.addRuntimePatternToMemory(nlpPattern, toolCallDetails);
        
        if (patternInMemory) {
            await this.persistRuntimePattern(patternInMemory);
            return patternInMemory;
        }
        return null;
    }

    /**
     * Extract Variables from NLP - Parses NLP text to identify variable placeholders
     */
    private extractVariablesFromNLP(nlpText: string): Variable[] {
        const variables: Variable[] = [];
        
        // Look for common variable patterns in NLP text
        const patterns = [
            /\{(\w+)\}/g,           // {variable}
            /\$\{(\w+)\}/g,         // ${variable}
            /\[(\w+)\]/g,           // [variable]
            /\*(\w+)\*/g,           // *variable*
            /\b(file|path|name|query|text|input|output)\b/gi  // Common parameter names
        ];

        let position = 0;
        for (const pattern of patterns) {
            let match;
            while ((match = pattern.exec(nlpText)) !== null) {
                const varName = match[1] || match[0].toLowerCase();
                
                // Avoid duplicates
                if (!variables.some(v => v.name === varName)) {
                    variables.push({
                        name: varName,
                        position: position++,
                        type: this.inferVariableType(varName),
                        description: `Auto-extracted variable: ${varName}`
                    });
                }
            }
        }

        // If no specific variables found, add a generic 'input' variable
        if (variables.length === 0) {
            variables.push({
                name: 'input',
                position: 0,
                type: 'string',
                description: 'Generic input parameter'
            });
        }

        return variables;
    }

    /**
     * Infer Variable Type - Attempts to determine variable type from name
     */
    private inferVariableType(varName: string): string {
        const name = varName.toLowerCase();
        
        if (name.includes('count') || name.includes('num') || name.includes('size')) {
            return 'number';
        }
        
        if (name.includes('enable') || name.includes('is') || name.includes('has')) {
            return 'boolean';
        }
        
        if (name.includes('list') || name.includes('array') || name.includes('items')) {
            return 'array';
        }
        
        return 'string';
    }

    async getPattern(patternId: string): Promise<Pattern | undefined> {
        await this.ensureDbPatternsLoaded();
        return this.patterns.get(patternId);
    }

    async getPatternsByTool(toolName: string): Promise<Pattern[]> {
        await this.ensureDbPatternsLoaded();
        return Array.from(this.patterns.values()).filter(p => p.toolName === toolName);
    }

    setFastPathThreshold(threshold: number): void {
        this.fastPathThreshold = Math.max(0.1, Math.min(0.99, threshold));
        this.logger.info('CommandMapProcessor', `Updated fast path threshold to ${this.fastPathThreshold}`);
    }
} 
```

## File: /Users/deepsaint/Desktop/symphony-sdk/src/cache/command-map.xml

```xml
<?xml version="1.0" encoding="UTF-8"?>
<!-- 
  Command Map for Symphonic Agent System
  
  This is our high-performance pattern matching system that maps natural language
  to tool executions. It acts as a deterministic fast-path for known patterns,
  reducing the need for full LLM inference when confidence is high.
  
  Key features:
  - Pattern-based tool dispatch
  - Confidence scoring and evolution
  - Variable capture and type safety
  - Usage statistics for optimization
  - Grouped by tool domains
-->
<CommandMap version="2.0">
  
  <!-- File and Code Search Patterns -->
  <PatternGroup type="search">
    
    <Pattern id="FILE_SEARCH" confidence="0.95">
      <Linguistic>
        <Trigger>search for * in *</Trigger>
        <Variables>
          <Variable name="query" position="1" type="string">
            <Type>string</Type>
            <Description>Search query or term</Description>
          </Variable>
          <Variable name="target" position="2" type="string">
            <Type>string</Type>
            <Description>Search target (files, directory, codebase)</Description>
          </Variable>
        </Variables>
        <Examples>
          <Example>search for authentication in codebase</Example>
          <Example>search for React components in src</Example>
          <Example>search for API endpoints in backend</Example>
        </Examples>
      </Linguistic>
      <ToolMapping>
        <Tool>codebase_search</Tool>
        <Parameters>
          <Parameter name="query" value="${query}"/>
          <Parameter name="target_directories" value="[${target}]"/>
        </Parameters>
      </ToolMapping>
      <UsageStats>
        <SuccessCount>43</SuccessCount>
        <FailureCount>2</FailureCount>
        <LastUsed>2024-01-15T10:30:00Z</LastUsed>
        <AverageLatency>1200ms</AverageLatency>
      </UsageStats>
    </Pattern>

    <Pattern id="FIND_FILES" confidence="0.92">
      <Linguistic>
        <Trigger>find * files *</Trigger>
        <Variables>
          <Variable name="filetype" position="1" type="string">
            <Type>string</Type>
            <Description>File type or extension</Description>
          </Variable>
          <Variable name="location" position="2" type="string">
            <Type>string</Type>
            <Description>Location to search</Description>
          </Variable>
        </Variables>
        <Examples>
          <Example>find TypeScript files in src</Example>
          <Example>find config files in project</Example>
          <Example>find test files containing database</Example>
        </Examples>
      </Linguistic>
      <ToolMapping>
        <Tool>file_search</Tool>
        <Parameters>
          <Parameter name="query" value="${filetype}"/>
          <Parameter name="path" value="${location}"/>
        </Parameters>
      </ToolMapping>
      <UsageStats>
        <SuccessCount>89</SuccessCount>
        <FailureCount>7</FailureCount>
        <LastUsed>2024-01-15T11:45:00Z</LastUsed>
        <AverageLatency>800ms</AverageLatency>
      </UsageStats>
    </Pattern>

    <Pattern id="GREP_PATTERN" confidence="0.94">
      <Linguistic>
        <Trigger>grep * in *</Trigger>
        <Variables>
          <Variable name="pattern" position="1" type="string">
            <Type>string</Type>
            <Description>Search pattern or regex</Description>
          </Variable>
          <Variable name="scope" position="2" type="string">
            <Type>string</Type>
            <Description>Files or directories to search</Description>
          </Variable>
        </Variables>
        <Examples>
          <Example>grep TODO in src directory</Example>
          <Example>grep console.log in JavaScript files</Example>
          <Example>grep error patterns in logs</Example>
        </Examples>
      </Linguistic>
      <ToolMapping>
        <Tool>grep_search</Tool>
        <Parameters>
          <Parameter name="query" value="${pattern}"/>
          <Parameter name="include_pattern" value="${scope}"/>
        </Parameters>
      </ToolMapping>
      <UsageStats>
        <SuccessCount>156</SuccessCount>
        <FailureCount>12</FailureCount>
        <LastUsed>2024-01-15T14:20:00Z</LastUsed>
        <AverageLatency>650ms</AverageLatency>
      </UsageStats>
    </Pattern>
    
  </PatternGroup>

  <!-- File Operations Patterns -->
  <PatternGroup type="file_operations">
    
    <Pattern id="EDIT_FILE" confidence="0.90">
      <Linguistic>
        <Trigger>edit * file</Trigger>
        <Variables>
          <Variable name="filename" position="1" type="string">
            <Type>string</Type>
            <Description>File to edit</Description>
          </Variable>
        </Variables>
        <Examples>
          <Example>edit config.json file</Example>
          <Example>edit package.json file</Example>
          <Example>edit the main component file</Example>
        </Examples>
      </Linguistic>
      <ToolMapping>
        <Tool>edit_file</Tool>
        <Parameters>
          <Parameter name="target_file" value="${filename}"/>
        </Parameters>
      </ToolMapping>
      <UsageStats>
        <SuccessCount>89</SuccessCount>
        <FailureCount>8</FailureCount>
        <LastUsed>2024-01-15T16:10:00Z</LastUsed>
        <AverageLatency>450ms</AverageLatency>
      </UsageStats>
    </Pattern>

    <Pattern id="READ_FILE" confidence="0.92">
      <Linguistic>
        <Trigger>read * file</Trigger>
        <Variables>
          <Variable name="filename" position="1" type="string">
            <Type>string</Type>
            <Description>File to read</Description>
          </Variable>
        </Variables>
        <Examples>
          <Example>read package.json file</Example>
          <Example>read the README file</Example>
          <Example>read configuration file</Example>
        </Examples>
      </Linguistic>
      <ToolMapping>
        <Tool>read_file</Tool>
        <Parameters>
          <Parameter name="target_file" value="${filename}"/>
        </Parameters>
      </ToolMapping>
      <UsageStats>
        <SuccessCount>134</SuccessCount>
        <FailureCount>6</FailureCount>
        <LastUsed>2024-01-15T15:45:00Z</LastUsed>
        <AverageLatency>320ms</AverageLatency>
      </UsageStats>
    </Pattern>

    <Pattern id="LIST_DIRECTORY" confidence="0.89">
      <Linguistic>
        <Trigger>list * directory</Trigger>
        <Variables>
          <Variable name="path" position="1" type="string">
            <Type>string</Type>
            <Description>Directory path to list</Description>
          </Variable>
        </Variables>
        <Examples>
          <Example>list src directory</Example>
          <Example>list project directory</Example>
          <Example>list components directory</Example>
        </Examples>
      </Linguistic>
      <ToolMapping>
        <Tool>list_dir</Tool>
        <Parameters>
          <Parameter name="relative_workspace_path" value="${path}"/>
        </Parameters>
      </ToolMapping>
      <UsageStats>
        <SuccessCount>98</SuccessCount>
        <FailureCount>4</FailureCount>
        <LastUsed>2024-01-15T11:20:00Z</LastUsed>
        <AverageLatency>180ms</AverageLatency>
      </UsageStats>
    </Pattern>

    <Pattern id="PROJECT_STRUCTURE" confidence="0.86">
      <Linguistic>
        <Trigger>show project structure</Trigger>
        <Variables />
        <Examples>
          <Example>show project structure</Example>
          <Example>display project structure</Example>
          <Example>list project structure</Example>
        </Examples>
      </Linguistic>
      <ToolMapping>
        <Tool>list_dir</Tool>
        <Parameters>
          <Parameter name="relative_workspace_path" value="."/>
        </Parameters>
      </ToolMapping>
      <UsageStats>
        <SuccessCount>45</SuccessCount>
        <FailureCount>2</FailureCount>
        <LastUsed>2024-01-15T08:30:00Z</LastUsed>
        <AverageLatency>250ms</AverageLatency>
      </UsageStats>
    </Pattern>
    
  </PatternGroup>

  <!-- Command Execution Patterns -->
  <PatternGroup type="commands">
    
    <Pattern id="RUN_COMMAND" confidence="0.88">
      <Linguistic>
        <Trigger>run * command</Trigger>
        <Variables>
          <Variable name="command" position="1" type="string">
            <Type>string</Type>
            <Description>Command to execute</Description>
          </Variable>
        </Variables>
        <Examples>
          <Example>run npm install command</Example>
          <Example>run build command</Example>
          <Example>run test command</Example>
        </Examples>
      </Linguistic>
      <ToolMapping>
        <Tool>run_terminal_cmd</Tool>
        <Parameters>
          <Parameter name="command" value="${command}"/>
        </Parameters>
      </ToolMapping>
      <UsageStats>
        <SuccessCount>78</SuccessCount>
        <FailureCount>6</FailureCount>
        <LastUsed>2024-01-15T12:15:00Z</LastUsed>
        <AverageLatency>2100ms</AverageLatency>
      </UsageStats>
    </Pattern>

    <Pattern id="INSTALL_PACKAGE" confidence="0.91">
      <Linguistic>
        <Trigger>install * package</Trigger>
        <Variables>
          <Variable name="package" position="1" type="string">
            <Type>string</Type>
            <Description>Package name to install</Description>
          </Variable>
        </Variables>
        <Examples>
          <Example>install react package</Example>
          <Example>install typescript package</Example>
          <Example>install lodash package</Example>
        </Examples>
      </Linguistic>
      <ToolMapping>
        <Tool>run_terminal_cmd</Tool>
        <Parameters>
          <Parameter name="command" value="npm install ${package}"/>
        </Parameters>
      </ToolMapping>
      <UsageStats>
        <SuccessCount>45</SuccessCount>
        <FailureCount>3</FailureCount>
        <LastUsed>2024-01-15T09:30:00Z</LastUsed>
        <AverageLatency>15000ms</AverageLatency>
      </UsageStats>
    </Pattern>

    <Pattern id="CHECK_DEPENDENCIES" confidence="0.84">
      <Linguistic>
        <Trigger>check * dependencies</Trigger>
        <Variables>
          <Variable name="type" position="1" type="string">
            <Type>string</Type>
            <Description>Type of dependencies (project, package, etc.)</Description>
          </Variable>
        </Variables>
        <Examples>
          <Example>check project dependencies</Example>
          <Example>check package dependencies</Example>
          <Example>check outdated dependencies</Example>
        </Examples>
      </Linguistic>
      <ToolMapping>
        <Tool>read_file</Tool>
        <Parameters>
          <Parameter name="target_file" value="package.json"/>
        </Parameters>
      </ToolMapping>
      <UsageStats>
        <SuccessCount>67</SuccessCount>
        <FailureCount>3</FailureCount>
        <LastUsed>2024-01-15T13:15:00Z</LastUsed>
        <AverageLatency>400ms</AverageLatency>
      </UsageStats>
    </Pattern>
    
  </PatternGroup>

  <!-- Analysis and Debugging Patterns -->
  <PatternGroup type="analysis">
    
    <Pattern id="ANALYZE_CODE" confidence="0.85">
      <Linguistic>
        <Trigger>analyze * code</Trigger>
        <Variables>
          <Variable name="target" position="1" type="string">
            <Type>string</Type>
            <Description>Code target to analyze</Description>
          </Variable>
        </Variables>
        <Examples>
          <Example>analyze performance code</Example>
          <Example>analyze authentication code</Example>
          <Example>analyze error handling code</Example>
        </Examples>
      </Linguistic>
      <ToolMapping>
        <Tool>codebase_search</Tool>
        <Parameters>
          <Parameter name="query" value="${target}"/>
        </Parameters>
      </ToolMapping>
      <UsageStats>
        <SuccessCount>34</SuccessCount>
        <FailureCount>8</FailureCount>
        <LastUsed>2024-01-15T14:50:00Z</LastUsed>
        <AverageLatency>2500ms</AverageLatency>
      </UsageStats>
    </Pattern>

    <Pattern id="DEBUG_ISSUE" confidence="0.82">
      <Linguistic>
        <Trigger>debug * issue</Trigger>
        <Variables>
          <Variable name="problem" position="1" type="string">
            <Type>string</Type>
            <Description>Issue or problem to debug</Description>
          </Variable>
        </Variables>
        <Examples>
          <Example>debug authentication issue</Example>
          <Example>debug performance issue</Example>
          <Example>debug build issue</Example>
        </Examples>
      </Linguistic>
      <ToolMapping>
        <Tool>grep_search</Tool>
        <Parameters>
          <Parameter name="query" value="error|Error|ERROR|exception|Exception|fail|Fail"/>
        </Parameters>
      </ToolMapping>
      <UsageStats>
        <SuccessCount>56</SuccessCount>
        <FailureCount>12</FailureCount>
        <LastUsed>2024-01-15T16:30:00Z</LastUsed>
        <AverageLatency>1800ms</AverageLatency>
      </UsageStats>
    </Pattern>
    
  </PatternGroup>

  <!-- Web and API Patterns -->
  <PatternGroup type="web_api">
    
    <Pattern id="SEARCH_WEB" confidence="0.93">
      <Linguistic>
        <Trigger>search * on web</Trigger>
        <Variables>
          <Variable name="query" position="1" type="string">
            <Type>string</Type>
            <Description>Web search query</Description>
          </Variable>
        </Variables>
        <Examples>
          <Example>search React best practices on web</Example>
          <Example>search TypeScript tutorials on web</Example>
          <Example>search Node.js performance on web</Example>
        </Examples>
      </Linguistic>
      <ToolMapping>
        <Tool>web_search</Tool>
        <Parameters>
          <Parameter name="search_term" value="${query}"/>
        </Parameters>
      </ToolMapping>
      <UsageStats>
        <SuccessCount>203</SuccessCount>
        <FailureCount>7</FailureCount>
        <LastUsed>2024-01-15T17:10:00Z</LastUsed>
        <AverageLatency>3200ms</AverageLatency>
      </UsageStats>
    </Pattern>

    <Pattern id="API_DOCUMENTATION" confidence="0.87">
      <Linguistic>
        <Trigger>find * API documentation</Trigger>
        <Variables>
          <Variable name="api" position="1" type="string">
            <Type>string</Type>
            <Description>API or library name</Description>
          </Variable>
        </Variables>
        <Examples>
          <Example>find React API documentation</Example>
          <Example>find Express API documentation</Example>
          <Example>find MongoDB API documentation</Example>
        </Examples>
      </Linguistic>
      <ToolMapping>
        <Tool>web_search</Tool>
        <Parameters>
          <Parameter name="search_term" value="${api} API documentation official"/>
        </Parameters>
      </ToolMapping>
      <UsageStats>
        <SuccessCount>78</SuccessCount>
        <FailureCount>5</FailureCount>
        <LastUsed>2024-01-15T10:45:00Z</LastUsed>
        <AverageLatency>2800ms</AverageLatency>
      </UsageStats>
    </Pattern>
    
  </PatternGroup>
  
</CommandMap> 
```

## File: /Users/deepsaint/Desktop/symphony-sdk/src/cache/utils/ExecutionAnalyzer.ts

```ts
import { Pattern as CommandMapPattern } from '../map-processor';

interface ToolUsageStats {
    name: string;
    totalCalls: number;
    successfulCalls: number;
    failedCalls: number;
    avgExecutionTime: number;
    totalExecutionTime: number;
    successRate: number;
}

/**
 * Execution analysis utilities for ContextAPI
 */
export class ExecutionAnalyzer {
    
    /**
     * Calculate average execution time
     */
    static calculateAverageExecutionTime(executions: any[]): number {
        if (executions.length === 0) return 0;
        
        const totalTime = executions.reduce((sum, exec) => sum + (exec.execution_time_ms || 0), 0);
        return Math.round(totalTime / executions.length);
    }

    /**
     * Analyze tool usage patterns
     */
    static analyzeToolUsage(executions: any[]): ToolUsageStats[] {
        const toolUsage = new Map<string, any>();
        
        executions.forEach(exec => {
            const toolName = exec.tool_name;
            if (!toolUsage.has(toolName)) {
                toolUsage.set(toolName, {
                    name: toolName,
                    totalCalls: 0,
                    successfulCalls: 0,
                    failedCalls: 0,
                    avgExecutionTime: 0,
                    totalExecutionTime: 0
                });
            }
            
            const stats = toolUsage.get(toolName)!;
            stats.totalCalls++;
            stats.totalExecutionTime += exec.execution_time_ms || 0;
            
            if (exec.success) {
                stats.successfulCalls++;
            } else {
                stats.failedCalls++;
            }
            
            stats.avgExecutionTime = stats.totalExecutionTime / stats.totalCalls;
        });
        
        return Array.from(toolUsage.values())
            .sort((a, b) => b.totalCalls - a.totalCalls)
            .map(tool => ({
                ...tool,
                successRate: Math.round((tool.successfulCalls / tool.totalCalls) * 100),
                avgExecutionTime: Math.round(tool.avgExecutionTime)
            }));
    }

    /**
     * Analyze common failures
     */
    static analyzeCommonFailures(failedExecutions: any[]): any {
        const failureReasons = new Map<string, number>();
        const failuresByTool = new Map<string, number>();
        
        failedExecutions.forEach(exec => {
            // Count failure reasons
            const reason = exec.error_details || 'Unknown error';
            failureReasons.set(reason, (failureReasons.get(reason) || 0) + 1);
            
            // Count failures by tool
            const toolName = exec.tool_name;
            failuresByTool.set(toolName, (failuresByTool.get(toolName) || 0) + 1);
        });
        
        return {
            totalFailures: failedExecutions.length,
            topFailureReasons: Array.from(failureReasons.entries())
                .sort((a, b) => b[1] - a[1])
                .slice(0, 5)
                .map(([reason, count]) => ({ reason, count })),
            failuresByTool: Array.from(failuresByTool.entries())
                .sort((a, b) => b[1] - a[1])
                .slice(0, 5)
                .map(([tool, count]) => ({ tool, count }))
        };
    }

    /**
     * Analyze performance trends
     */
    static analyzePerformanceTrends(executions: any[]): any {
        if (executions.length === 0) return {};
        
        // Sort by timestamp
        const sortedExecutions = executions.sort((a, b) => 
            new Date(a.created_at).getTime() - new Date(b.created_at).getTime()
        );
        
        const now = Date.now();
        const oneDayAgo = now - (24 * 60 * 60 * 1000);
        const oneWeekAgo = now - (7 * 24 * 60 * 60 * 1000);
        
        const last24h = sortedExecutions.filter(e => 
            new Date(e.created_at).getTime() > oneDayAgo
        );
        const lastWeek = sortedExecutions.filter(e => 
            new Date(e.created_at).getTime() > oneWeekAgo
        );
        
        return {
            totalExecutions: executions.length,
            last24hExecutions: last24h.length,
            lastWeekExecutions: lastWeek.length,
            last24hSuccessRate: last24h.length > 0 ? 
                Math.round((last24h.filter(e => e.success).length / last24h.length) * 100) : 0,
            lastWeekSuccessRate: lastWeek.length > 0 ? 
                Math.round((lastWeek.filter(e => e.success).length / lastWeek.length) * 100) : 0,
            avgExecutionTime24h: this.calculateAverageExecutionTime(last24h),
            avgExecutionTimeWeek: this.calculateAverageExecutionTime(lastWeek),
            trend: this.calculateTrend(last24h, lastWeek)
        };
    }

    /**
     * Generate performance recommendations
     */
    static generatePerformanceRecommendations(executions: any[]): string[] {
        const recommendations: string[] = [];
        
        if (executions.length === 0) {
            recommendations.push('No execution data available for analysis');
            return recommendations;
        }
        
        const successRate = (executions.filter(e => e.success).length / executions.length) * 100;
        const avgTime = this.calculateAverageExecutionTime(executions);
        
        if (successRate < 70) {
            recommendations.push('Success rate is below 70% - review failing tool configurations');
        }
        
        if (avgTime > 5000) {
            recommendations.push('Average execution time is high - consider optimizing tool performance');
        }
        
        const toolUsage = this.analyzeToolUsage(executions);
        const problematicTools = toolUsage.filter((tool: ToolUsageStats) => tool.successRate < 60);
        
        if (problematicTools.length > 0) {
            recommendations.push(`Review tools with low success rates: ${problematicTools.map((t: ToolUsageStats) => t.name).join(', ')}`);
        }
        
        const highUsageTools = toolUsage.filter((tool: ToolUsageStats) => tool.totalCalls > executions.length * 0.3);
        if (highUsageTools.length > 0) {
            recommendations.push(`Consider caching for frequently used tools: ${highUsageTools.map((t: ToolUsageStats) => t.name).join(', ')}`);
        }
        
        return recommendations;
    }

    /**
     * Analyze current performance metrics
     */
    static analyzeCurrentPerformance(executions: any[]): any {
        if (executions.length === 0) {
            return { noData: true };
        }
        
        const successCount = executions.filter(e => e.success).length;
        const totalTime = executions.reduce((sum, e) => sum + (e.execution_time_ms || 0), 0);
        
        return {
            totalExecutions: executions.length,
            successRate: Math.round((successCount / executions.length) * 100),
            averageExecutionTime: Math.round(totalTime / executions.length),
            totalExecutionTime: totalTime,
            performance: successCount / executions.length > 0.8 ? 'good' : 
                        successCount / executions.length > 0.6 ? 'fair' : 'poor'
        };
    }

    /**
     * Identify performance bottlenecks
     */
    static identifyBottlenecks(executions: any[]): any[] {
        const bottlenecks: any[] = [];
        
        const toolUsage = this.analyzeToolUsage(executions);
        const avgTime = this.calculateAverageExecutionTime(executions);
        
        // Slow tools
        const slowTools = toolUsage.filter((tool: ToolUsageStats) => tool.avgExecutionTime > avgTime * 2);
        slowTools.forEach((tool: ToolUsageStats) => {
            bottlenecks.push({
                type: 'slow_execution',
                tool: tool.name,
                impact: 'high',
                description: `${tool.name} takes ${tool.avgExecutionTime}ms on average (${Math.round(tool.avgExecutionTime / avgTime)}x slower than average)`
            });
        });
        
        // Frequently failing tools
        const unreliableTools = toolUsage.filter((tool: ToolUsageStats) => tool.successRate < 70 && tool.totalCalls > 5);
        unreliableTools.forEach((tool: ToolUsageStats) => {
            bottlenecks.push({
                type: 'high_failure_rate',
                tool: tool.name,
                impact: 'medium',
                description: `${tool.name} has ${tool.successRate}% success rate with ${tool.failedCalls} failures`
            });
        });
        
        return bottlenecks;
    }

    /**
     * Identify optimization opportunities
     */
    static identifyOptimizationOpportunities(executions: any[], patterns: CommandMapPattern[]): any[] {
        const opportunities: any[] = [];
        
        const toolUsage = this.analyzeToolUsage(executions);
        
        // High-usage tools that could benefit from caching
        const cachingCandidates = toolUsage.filter((tool: ToolUsageStats) => 
            tool.totalCalls > 10 && tool.successRate > 80
        );
        
        cachingCandidates.forEach((tool: ToolUsageStats) => {
            opportunities.push({
                type: 'caching',
                tool: tool.name,
                potential: 'high',
                description: `${tool.name} used ${tool.totalCalls} times with ${tool.successRate}% success - good caching candidate`
            });
        });
        
        // Patterns with room for improvement
        const improvablePatterns = patterns.filter(p => {
            const usage = p.usageStats.successCount + p.usageStats.failureCount;
            return usage > 5 && p.confidence < 0.8;
        });
        
        improvablePatterns.forEach(pattern => {
            opportunities.push({
                type: 'pattern_optimization',
                tool: pattern.toolName,
                potential: 'medium',
                description: `Pattern "${pattern.trigger}" has ${pattern.confidence} confidence with room for improvement`
            });
        });
        
        return opportunities;
    }

    /**
     * Generate optimization recommendations
     */
    static generateOptimizationRecommendations(executions: any[], patterns: CommandMapPattern[]): string[] {
        const recommendations: string[] = [];
        
        const bottlenecks = this.identifyBottlenecks(executions);
        const opportunities = this.identifyOptimizationOpportunities(executions, patterns);
        
        if (bottlenecks.length > 0) {
            recommendations.push(`Address ${bottlenecks.length} performance bottlenecks`);
        }
        
        if (opportunities.length > 0) {
            const cachingOps = opportunities.filter(o => o.type === 'caching').length;
            if (cachingOps > 0) {
                recommendations.push(`Implement caching for ${cachingOps} high-usage tools`);
            }
            
            const patternOps = opportunities.filter(o => o.type === 'pattern_optimization').length;
            if (patternOps > 0) {
                recommendations.push(`Optimize ${patternOps} underperforming patterns`);
            }
        }
        
        return recommendations;
    }

    /**
     * Estimate optimization impact
     */
    static estimateOptimizationImpact(executions: any[]): any {
        if (executions.length === 0) return {};
        
        const currentPerf = this.analyzeCurrentPerformance(executions);
        const bottlenecks = this.identifyBottlenecks(executions);
        
        // Estimate potential improvements
        let potentialTimeReduction = 0;
        let potentialSuccessIncrease = 0;
        
        bottlenecks.forEach(bottleneck => {
            if (bottleneck.type === 'slow_execution') {
                potentialTimeReduction += 0.3; // 30% improvement estimate
            }
            if (bottleneck.type === 'high_failure_rate') {
                potentialSuccessIncrease += 0.15; // 15% improvement estimate
            }
        });
        
        return {
            currentSuccessRate: currentPerf.successRate,
            currentAvgTime: currentPerf.averageExecutionTime,
            estimatedSuccessRateImprovement: Math.min(95, currentPerf.successRate + (potentialSuccessIncrease * 100)),
            estimatedTimeReduction: Math.round(currentPerf.averageExecutionTime * (1 - potentialTimeReduction)),
            confidenceLevel: bottlenecks.length > 0 ? 'medium' : 'low'
        };
    }

    /**
     * Calculate trend direction
     */
    private static calculateTrend(recent: any[], older: any[]): string {
        if (recent.length === 0 || older.length === 0) return 'insufficient_data';
        
        const recentSuccessRate = recent.filter(e => e.success).length / recent.length;
        const olderSuccessRate = older.filter(e => e.success).length / older.length;
        
        if (recentSuccessRate > olderSuccessRate + 0.1) return 'improving';
        if (recentSuccessRate < olderSuccessRate - 0.1) return 'declining';
        return 'stable';
    }
} 
```

## File: /Users/deepsaint/Desktop/symphony-sdk/src/cache/utils/PatternAnalyzer.ts

```ts
import { Pattern as CommandMapPattern } from '../map-processor';

/**
 * Pattern analysis utilities for ContextAPI
 */
export class PatternAnalyzer {
    
    /**
     * Calculate match strength between task and pattern
     */
    static calculateMatchStrength(task: string, pattern: CommandMapPattern): number {
        const taskLower = task.toLowerCase();
        const triggerLower = pattern.trigger.toLowerCase();
        const toolLower = pattern.toolName.toLowerCase();
        
        // Exact matches get highest score
        if (taskLower === triggerLower) return 1.0;
        if (taskLower.includes(toolLower)) return 0.8;
        
        // Partial matches
        const triggerWords = triggerLower.split(' ');
        const taskWords = taskLower.split(' ');
        
        const matchingWords = triggerWords.filter(word => 
            taskWords.some(taskWord => taskWord.includes(word) || word.includes(taskWord))
        );
        
        return Math.min(0.9, matchingWords.length / Math.max(triggerWords.length, taskWords.length));
    }

    /**
     * Calculate pattern success rate
     */
    static calculatePatternSuccessRate(pattern: CommandMapPattern): number {
        const total = pattern.usageStats.successCount + pattern.usageStats.failureCount;
        return total > 0 ? Math.round((pattern.usageStats.successCount / total) * 100) : 0;
    }

    /**
     * Identify issues with a pattern
     */
    static identifyPatternIssues(pattern: CommandMapPattern): string[] {
        const issues: string[] = [];
        
        if (pattern.confidence < 0.3) {
            issues.push('Very low confidence');
        }
        
        const successRate = this.calculatePatternSuccessRate(pattern);
        if (successRate < 30) {
            issues.push('Low success rate');
        }
        
        const totalUsage = pattern.usageStats.successCount + pattern.usageStats.failureCount;
        if (totalUsage < 3) {
            issues.push('Insufficient usage data');
        }
        
        const daysSinceLastUsed = pattern.usageStats.lastUsed ? 
            (Date.now() - new Date(pattern.usageStats.lastUsed).getTime()) / (1000 * 60 * 60 * 24) : 
            999;
        
        if (daysSinceLastUsed > 30) {
            issues.push('Not used recently');
        }
        
        return issues;
    }

    /**
     * Analyze pattern trends
     */
    static analyzePatternTrends(patterns: CommandMapPattern[]): any {
        if (patterns.length === 0) return {};
        
        const avgConfidence = patterns.reduce((sum, p) => sum + p.confidence, 0) / patterns.length;
        const highPerformers = patterns.filter(p => this.calculatePatternSuccessRate(p) > 80).length;
        const lowPerformers = patterns.filter(p => this.calculatePatternSuccessRate(p) < 40).length;
        
        return {
            averageConfidence: Math.round(avgConfidence * 100) / 100,
            highPerformers,
            lowPerformers,
            totalPatterns: patterns.length,
            utilizationRate: patterns.filter(p => 
                (p.usageStats.successCount + p.usageStats.failureCount) > 0
            ).length / patterns.length
        };
    }

    /**
     * Generate pattern recommendations
     */
    static generatePatternRecommendations(patterns: CommandMapPattern[]): string[] {
        const recommendations: string[] = [];
        
        const lowConfidencePatterns = patterns.filter(p => p.confidence < 0.5);
        if (lowConfidencePatterns.length > 0) {
            recommendations.push(`Review ${lowConfidencePatterns.length} low-confidence patterns`);
        }
        
        const unusedPatterns = patterns.filter(p => 
            (p.usageStats.successCount + p.usageStats.failureCount) === 0
        );
        if (unusedPatterns.length > 0) {
            recommendations.push(`Consider removing ${unusedPatterns.length} unused patterns`);
        }
        
        const highPerformers = patterns.filter(p => this.calculatePatternSuccessRate(p) > 90);
        if (highPerformers.length > 0) {
            recommendations.push(`Leverage insights from ${highPerformers.length} high-performing patterns`);
        }
        
        return recommendations;
    }
} 
```

## File: /Users/deepsaint/Desktop/symphony-sdk/src/cache/utils/TaskAnalyzer.ts

```ts
import { Pattern as CommandMapPattern } from '../map-processor';
import { LearnFromExecutionParams } from '../../api/IContextAPI';

/**
 * Task analysis utilities for ContextAPI
 */
export class TaskAnalyzer {
    
    /**
     * Generate task-specific recommendations
     */
    static generateTaskRecommendations(task: string, suggestions: any[]): string[] {
        const recommendations: string[] = [];
        
        if (suggestions.length === 0) {
            recommendations.push('No existing patterns found for this task - execution will create new learning data');
            recommendations.push('Consider breaking down complex tasks into smaller components');
            return recommendations;
        }
        
        const highConfidenceSuggestions = suggestions.filter(s => s.confidence > 0.8);
        if (highConfidenceSuggestions.length > 0) {
            recommendations.push(`High confidence tools available: ${highConfidenceSuggestions.map(s => s.toolName).join(', ')}`);
        }
        
        const lowSuccessRateTools = suggestions.filter(s => s.successRate < 70);
        if (lowSuccessRateTools.length > 0) {
            recommendations.push(`Be cautious with: ${lowSuccessRateTools.map(s => s.toolName).join(', ')} (low success rate)`);
        }
        
        // Task-specific analysis
        const taskLower = task.toLowerCase();
        if (taskLower.includes('email') || taskLower.includes('message')) {
            recommendations.push('For communication tasks, consider user context and tone');
        }
        
        if (taskLower.includes('search') || taskLower.includes('find')) {
            recommendations.push('For search tasks, try specific keywords before broad queries');
        }
        
        if (taskLower.includes('analyze') || taskLower.includes('report')) {
            recommendations.push('For analysis tasks, gather data first then synthesize insights');
        }
        
        return recommendations;
    }

    /**
     * Generate learning insights from execution
     */
    static generateLearningInsights(params: LearnFromExecutionParams, pattern?: CommandMapPattern): any {
        const insights: any = {
            executionResult: params.success ? 'successful' : 'failed',
            toolName: params.toolName,
            executionTime: params.executionTime,
            learningValue: 'medium'
        };
        
        // Pattern-based insights
        if (pattern) {
            insights.patternInfo = {
                exists: true,
                confidence: pattern.confidence,
                totalUsage: pattern.usageStats.successCount + pattern.usageStats.failureCount,
                successRate: pattern.usageStats.successCount / 
                    Math.max(1, pattern.usageStats.successCount + pattern.usageStats.failureCount) * 100
            };
            
            if (params.success && pattern.confidence < 0.8) {
                insights.learningValue = 'high';
                insights.note = 'Successful execution will boost pattern confidence';
            }
            
            if (!params.success && pattern.confidence > 0.7) {
                insights.learningValue = 'high';
                insights.note = 'Unexpected failure for high-confidence pattern - investigation needed';
            }
        } else {
            insights.patternInfo = {
                exists: false,
                note: 'New tool usage - will create learning data for future reference'
            };
            insights.learningValue = 'high';
        }
        
        // Execution time insights
        if (params.executionTime > 10000) {
            insights.performanceNote = 'Slow execution - consider optimization';
        } else if (params.executionTime < 100) {
            insights.performanceNote = 'Very fast execution - good tool choice';
        }
        
        // User feedback insights
        if (params.userFeedback) {
            insights.userFeedback = {
                received: params.userFeedback,
                impact: params.userFeedback === 'positive' ? 'confidence_boost' :
                       params.userFeedback === 'negative' ? 'confidence_reduction' : 'neutral'
            };
        }
        
        // Context insights
        if (params.context) {
            insights.contextAvailable = true;
            insights.contextSize = JSON.stringify(params.context).length;
        }
        
        return insights;
    }

    /**
     * Analyze task complexity
     */
    static analyzeTaskComplexity(task: string): any {
        const words = task.toLowerCase().split(' ');
        const complexity = {
            wordCount: words.length,
            level: 'simple',
            factors: [] as string[],
            recommendations: [] as string[]
        };
        
        // Word count analysis
        if (words.length > 20) {
            complexity.level = 'complex';
            complexity.factors.push('Long description');
            complexity.recommendations.push('Consider breaking into smaller tasks');
        } else if (words.length > 10) {
            complexity.level = 'moderate';
            complexity.factors.push('Moderate length');
        }
        
        // Action word analysis
        const actionWords = ['create', 'analyze', 'generate', 'process', 'transform', 'calculate'];
        const foundActions = actionWords.filter(action => task.toLowerCase().includes(action));
        
        if (foundActions.length > 2) {
            complexity.level = 'complex';
            complexity.factors.push('Multiple actions required');
            complexity.recommendations.push('Sequence actions logically');
        }
        
        // Entity analysis
        const entityIndicators = ['file', 'data', 'email', 'report', 'document', 'image'];
        const foundEntities = entityIndicators.filter(entity => task.toLowerCase().includes(entity));
        
        if (foundEntities.length > 2) {
            complexity.factors.push('Multiple entity types');
            if (complexity.level === 'simple') complexity.level = 'moderate';
        }
        
        return complexity;
    }

    /**
     * Suggest task decomposition
     */
    static suggestTaskDecomposition(task: string): any {
        const complexity = this.analyzeTaskComplexity(task);
        
        if (complexity.level === 'simple') {
            return {
                needsDecomposition: false,
                reason: 'Task is simple enough for single execution'
            };
        }
        
        const decomposition = {
            needsDecomposition: true,
            suggestedSteps: [] as string[],
            reasoning: [] as string[]
        };
        
        const taskLower = task.toLowerCase();
        
        // Common patterns
        if (taskLower.includes('analyze') && taskLower.includes('report')) {
            decomposition.suggestedSteps = [
                'Gather and prepare data',
                'Perform analysis',
                'Generate insights',
                'Create report format',
                'Compile final report'
            ];
            decomposition.reasoning.push('Analysis and reporting require sequential steps');
        }
        
        if (taskLower.includes('email') && (taskLower.includes('send') || taskLower.includes('reply'))) {
            decomposition.suggestedSteps = [
                'Understand context and requirements',
                'Draft email content',
                'Review and refine message',
                'Send email'
            ];
            decomposition.reasoning.push('Email tasks benefit from careful composition');
        }
        
        if (taskLower.includes('search') || taskLower.includes('find')) {
            decomposition.suggestedSteps = [
                'Define search criteria',
                'Execute initial search',
                'Refine search if needed',
                'Analyze and filter results'
            ];
            decomposition.reasoning.push('Search tasks often require iteration');
        }
        
        // Generic decomposition if no specific pattern found
        if (decomposition.suggestedSteps.length === 0) {
            decomposition.suggestedSteps = [
                'Break down requirements',
                'Identify necessary tools',
                'Execute primary action',
                'Verify and refine results'
            ];
            decomposition.reasoning.push('Complex tasks benefit from systematic approach');
        }
        
        return decomposition;
    }

    /**
     * Analyze task success patterns
     */
    static analyzeTaskSuccessPatterns(task: string, patterns: CommandMapPattern[]): any {
        const taskWords = task.toLowerCase().split(' ');
        const relevantPatterns = patterns.filter(pattern => {
            const patternWords = pattern.trigger.toLowerCase().split(' ');
            return patternWords.some(word => taskWords.includes(word));
        });
        
        if (relevantPatterns.length === 0) {
            return {
                hasPatterns: false,
                recommendation: 'No similar patterns found - this will be a learning opportunity'
            };
        }
        
        const successRates = relevantPatterns.map(p => {
            const total = p.usageStats.successCount + p.usageStats.failureCount;
            return total > 0 ? p.usageStats.successCount / total : 0;
        });
        
        const avgSuccessRate = successRates.reduce((sum, rate) => sum + rate, 0) / successRates.length;
        const highPerformers = relevantPatterns.filter(p => {
            const total = p.usageStats.successCount + p.usageStats.failureCount;
            return total > 0 && (p.usageStats.successCount / total) > 0.8;
        });
        
        return {
            hasPatterns: true,
            totalRelevantPatterns: relevantPatterns.length,
            averageSuccessRate: Math.round(avgSuccessRate * 100),
            highPerformers: highPerformers.length,
            recommendation: avgSuccessRate > 0.7 ? 
                'Good success patterns exist for similar tasks' :
                'Mixed results for similar tasks - proceed with caution',
            suggestedTools: highPerformers.slice(0, 3).map(p => p.toolName)
        };
    }
} 
```

## File: /Users/deepsaint/Desktop/symphony-sdk/src/cache/context-api.ts

```ts
import { CommandMapProcessor, Pattern as CommandMapPattern, RuntimeToolCallDetails } from './map-processor';
import { ContextTreeBuilder, ContextQuery } from './tree-builder';
import { Logger } from '../utils/logger';
import { IDatabaseService } from '../db/IDatabaseService';
import { ToolResult } from '../types/sdk';
import { 
    IContextAPI,
    ValidateCommandParams,
    LearningUpdateRequest,
    ContextPruningRequest,
    PatternUpdateRequest,
    SuggestToolsParams,
    GetInsightsParams,
    LearnFromExecutionParams,
    ValidateContextTreeParams,
    AnalyzePatternsParams,
    OptimizePerformanceParams,
    MagicIntent
} from '../api/IContextAPI';
import { PatternAnalyzer } from './utils/PatternAnalyzer';
import { ExecutionAnalyzer } from './utils/ExecutionAnalyzer';
import { TaskAnalyzer } from './utils/TaskAnalyzer';

export interface ContextIntelligenceConfig {
    sessionId?: string;
    enableLearning?: boolean;
    confidenceThreshold?: number;
}

/**
 * Context API - Provides type-safe magic interface to context intelligence
 * All agents share this collective intelligence brain for learning and insights
 */
export class ContextAPI implements IContextAPI {
    private mapProcessor: CommandMapProcessor;
    private treeBuilder: ContextTreeBuilder;
    private logger: Logger;
    private database: IDatabaseService;
    private config: ContextIntelligenceConfig;

    constructor(database: IDatabaseService, config: ContextIntelligenceConfig = {}) {
        this.database = database;
        this.config = {
            enableLearning: true,
            confidenceThreshold: 0.7,
            ...config
        };
        this.logger = Logger.getInstance('ContextAPI');
        this.mapProcessor = CommandMapProcessor.getInstance(database);
        this.treeBuilder = ContextTreeBuilder.getInstance(database);
    }

    // ==========================================
    // TYPE-SAFE MAGIC INTERFACE
    // ==========================================

    /**
     * Type-safe magic method with overloads for perfect TypeScript experience
     */
    async useMagic(intent: 'validate_command_update', params: ValidateCommandParams): Promise<ToolResult>;
    async useMagic(intent: 'prune_context', params: ContextPruningRequest): Promise<ToolResult>;
    async useMagic(intent: 'update_pattern_stats', params: PatternUpdateRequest): Promise<ToolResult>;
    async useMagic(intent: 'validate_context_tree', params: ValidateContextTreeParams): Promise<ToolResult>;
    async useMagic(intent: 'suggest_tools', params: SuggestToolsParams): Promise<ToolResult>;
    async useMagic(intent: 'get_insights', params: GetInsightsParams): Promise<ToolResult>;
    async useMagic(intent: 'learn_from_execution', params: LearnFromExecutionParams): Promise<ToolResult>;
    async useMagic(intent: 'analyze_patterns', params: AnalyzePatternsParams): Promise<ToolResult>;
    async useMagic(intent: 'optimize_performance', params: OptimizePerformanceParams): Promise<ToolResult>;
    
    // Implementation
    async useMagic(intent: MagicIntent, params: any): Promise<ToolResult> {
        try {
            this.logger.info('ContextAPI', `Using magic: ${intent}`, { intent, hasParams: !!params });

            switch (intent) {
                case 'validate_command_update':
                    return this.validateCommandMapUpdate(params);
                case 'prune_context':
                    return this.pruneContextEntries(params);
                case 'update_pattern_stats':
                    return this.updatePatternStats(params);
                case 'validate_context_tree':
                    return this.validateContextTreeUpdate(params);
                case 'suggest_tools':
                    return this.suggestToolsForTask(params);
                case 'get_insights':
                    return this.getExecutionInsights(params);
                case 'learn_from_execution':
                    return this.learnFromExecution(params);
                case 'analyze_patterns':
                    return this.analyzePatterns(params);
                case 'optimize_performance':
                    return this.optimizePerformance(params);
                default:
                    return {
                        success: false,
                        error: `Unknown magic intent: ${intent}`
                    };
            }
        } catch (error) {
            this.logger.error('ContextAPI', `Magic failed for intent: ${intent}`, { error, intent, params });
            return {
                success: false,
                error: `Magic execution failed: ${error instanceof Error ? error.message : String(error)}`
            };
        }
    }

    // ==========================================
    // DEPRECATED WRAPPERS - For ToolRegistry backward compatibility
    // ==========================================

    public async updateLearningContext(params: LearningUpdateRequest): Promise<ToolResult> {
        this.logger.info('ContextAPI', 'Received call to deprecated updateLearningContext wrapper', { toolName: params.toolName });
        
        const executionTime = (params.contextData as any)?.executionTime || 0;
        const errorDetails = (params.result as any)?.error || undefined;

        const learnParams: LearnFromExecutionParams = {
            toolName: params.toolName,
            success: params.success,
            executionTime,
            userFeedback: params.userFeedback,
            context: {
                parameters: params.parameters,
                result: params.result,
                contextData: params.contextData
            },
            errorDetails
        };
        return this.useMagic('learn_from_execution', learnParams);
    }

    public async executeContextPruning(params: ContextPruningRequest): Promise<ToolResult> {
        this.logger.info('ContextAPI', 'Executing context pruning');
        return this.pruneContextEntries(params);
    }

    // ==========================================
    // NEW MAGIC METHODS
    // ==========================================

    /**
     * The actual implementation of the context pruning logic.
     */
    private async pruneContextEntries(params: ContextPruningRequest): Promise<ToolResult> {
        try {
            const maxAge = params.maxAge || 60 * 60 * 24 * 7; // Default to 7 days
            const cutoffDate = new Date(Date.now() - maxAge).toISOString();

            this.logger.info('ContextAPI', `Pruning tool executions older than ${cutoffDate}`);

            const result = await this.database.table('tool_executions')
                .delete({ created_at: { $lte: cutoffDate } });

            const prunedCount = result.rowsDeleted || 0;
            this.logger.info('ContextAPI', `Pruning complete. Pruned ${prunedCount} entries.`);

            return {
                success: true,
                result: {
                    pruningCompleted: true,
                    prunedEntries: prunedCount,
                    maxAge: params.maxAge
                }
            };
        } catch (error) {
            this.logger.error('ContextAPI', 'Context pruning failed', { error, params });
            return {
                success: false,
                error: `Context pruning failed: ${error instanceof Error ? error.message : String(error)}`
            };
        }
    }

    /**
     * Suggest tools for a given task using learned patterns
     */
    private async suggestToolsForTask(params: SuggestToolsParams): Promise<ToolResult> {
        try {
            this.logger.info('ContextAPI', 'Suggesting tools for task', { 
                task: params.task.substring(0, 50),
                agentName: params.agentName 
            });

            const patterns = await this.mapProcessor.getPatterns();
            const taskLower = params.task.toLowerCase();
            
            // Find patterns that match the task
            const relevantPatterns = patterns.filter(pattern => {
                const triggerMatch = taskLower.includes(pattern.trigger.toLowerCase()) ||
                                  pattern.trigger.toLowerCase().includes(taskLower);
                const toolMatch = taskLower.includes(pattern.toolName.toLowerCase());
                return triggerMatch || toolMatch;
            });

            // Score and rank suggestions
            const suggestions = relevantPatterns
                .map(pattern => {
                    const totalAttempts = pattern.usageStats.successCount + pattern.usageStats.failureCount;
                    const successRate = totalAttempts > 0 ? pattern.usageStats.successCount / totalAttempts : 0;
                    
                    return {
                        toolName: pattern.toolName,
                        confidence: pattern.confidence,
                        successRate: Math.round(successRate * 100),
                        totalUsage: totalAttempts,
                        lastUsed: pattern.usageStats.lastUsed,
                        reason: `Pattern match: "${pattern.trigger}"`,
                        matchStrength: PatternAnalyzer.calculateMatchStrength(params.task, pattern)
                    };
                })
                .sort((a, b) => (b.confidence * b.matchStrength) - (a.confidence * a.matchStrength))
                .slice(0, 5); // Top 5 suggestions

            // Add recommendations based on context
            const recommendations = TaskAnalyzer.generateTaskRecommendations(params.task, suggestions);

            return {
                success: true,
                result: {
                    task: params.task,
                    suggestions,
                    recommendations,
                    totalPatternsAnalyzed: patterns.length,
                    relevantPatterns: relevantPatterns.length
                }
            };

        } catch (error) {
            this.logger.error('ContextAPI', 'Tool suggestion failed', { error, params });
            return {
                success: false,
                error: `Tool suggestion failed: ${error instanceof Error ? error.message : String(error)}`
            };
        }
    }

    /**
     * Get execution insights and analytics
     */
    private async getExecutionInsights(params: GetInsightsParams): Promise<ToolResult> {
        try {
            this.logger.info('ContextAPI', 'Getting execution insights', params);

            // Get executions from database
            const allExecutions = await this.database.table('tool_executions').find();
            
            let filteredExecutions = allExecutions;
            
            // Apply filters
            if (params.sessionId) {
                filteredExecutions = filteredExecutions.filter((e: any) => e.session_id === params.sessionId);
            }
            if (params.toolName) {
                filteredExecutions = filteredExecutions.filter((e: any) => e.tool_name === params.toolName);
            }
            if (params.timeframe) {
                const cutoff = Date.now() - params.timeframe;
                filteredExecutions = filteredExecutions.filter((e: any) => 
                    new Date(e.created_at).getTime() > cutoff
                );
            }

            if (filteredExecutions.length === 0) {
                return {
                    success: true,
                    result: {
                        message: 'No executions found matching criteria',
                        totalExecutions: 0
                    }
                };
            }

            // Calculate insights
            const successfulExecutions = filteredExecutions.filter((e: any) => e.success);
            const failedExecutions = filteredExecutions.filter((e: any) => !e.success);
            
            const insights = {
                totalExecutions: filteredExecutions.length,
                successRate: Math.round((successfulExecutions.length / filteredExecutions.length) * 100),
                avgExecutionTime: ExecutionAnalyzer.calculateAverageExecutionTime(filteredExecutions),
                toolBreakdown: ExecutionAnalyzer.analyzeToolUsage(filteredExecutions),
                commonFailures: ExecutionAnalyzer.analyzeCommonFailures(failedExecutions),
                performanceTrends: ExecutionAnalyzer.analyzePerformanceTrends(filteredExecutions),
                recommendations: ExecutionAnalyzer.generatePerformanceRecommendations(filteredExecutions)
            };

            return {
                success: true,
                result: insights
            };

        } catch (error) {
            this.logger.error('ContextAPI', 'Getting execution insights failed', { error, params });
            return {
                success: false,
                error: `Execution insights failed: ${error instanceof Error ? error.message : String(error)}`
            };
        }
    }

    /**
     * Learn from execution results and update patterns
     */
    private async learnFromExecution(params: LearnFromExecutionParams): Promise<ToolResult> {
        try {
            this.logger.info('ContextAPI', 'Learning from execution', {
                toolName: params.toolName,
                success: params.success,
                executionTime: params.executionTime
            });

            // The recording is now handled by the ToolRegistry after every execution.
            // This method now focuses on post-execution analysis and pattern updates.

            const patterns = await this.mapProcessor.getPatterns();
            const pattern = patterns.find(p => p.toolName === params.toolName);
            let patternResult = null;
            
            if (pattern) {
                patternResult = await this.updatePatternStats({
                    nlpPattern: pattern.trigger,
                    toolName: params.toolName,
                    success: params.success,
                    executionTime: params.executionTime,
                    metadata: params.context
                });
            }

            // Generate learning insights
            const insights = TaskAnalyzer.generateLearningInsights(params, pattern);

            return {
                success: true,
                result: {
                    learned: true,
                    learningUpdated: true, 
                    patternUpdated: !!pattern && patternResult?.success,
                    patternId: pattern?.id,
                    confidence: pattern?.confidence,
                    insights,
                    recommendations: this.generateLearningRecommendations(
                        params.toolName, 
                        params.success, 
                        params.userFeedback
                    )
                }
            };

        } catch (error) {
            this.logger.error('ContextAPI', 'Learning from execution failed', { error, params });
            return {
                success: false,
                error: `Learning from execution failed: ${error instanceof Error ? error.message : String(error)}`
            };
        }
    }

    /**
     * Analyze patterns and performance trends
     */
    private async analyzePatterns(params: AnalyzePatternsParams): Promise<ToolResult> {
        try {
            this.logger.info('ContextAPI', 'Analyzing patterns', params);

            const patterns = await this.mapProcessor.getPatterns();
            let filteredPatterns = patterns;

            // Apply filters
            if (params.toolName) {
                filteredPatterns = patterns.filter(p => p.toolName === params.toolName);
            }
            if (params.minConfidence !== undefined) {
                filteredPatterns = filteredPatterns.filter(p => p.confidence >= params.minConfidence!);
            }

            // Analyze patterns
            const analysis = {
                totalPatterns: patterns.length,
                filteredPatterns: filteredPatterns.length,
                averageConfidence: filteredPatterns.length > 0 ? filteredPatterns.reduce((sum, p) => sum + p.confidence, 0) / filteredPatterns.length : 0,
                topPerformers: filteredPatterns
                    .sort((a, b) => b.confidence - a.confidence)
                    .slice(0, 5)
                    .map(p => ({
                        toolName: p.toolName,
                        trigger: p.trigger,
                        confidence: p.confidence,
                        successRate: PatternAnalyzer.calculatePatternSuccessRate(p)
                    })),
                underPerformers: filteredPatterns
                    .filter(p => p.confidence < 0.5 || PatternAnalyzer.calculatePatternSuccessRate(p) < 50)
                    .map(p => ({
                        toolName: p.toolName,
                        trigger: p.trigger,
                        confidence: p.confidence,
                        successRate: PatternAnalyzer.calculatePatternSuccessRate(p),
                        issues: PatternAnalyzer.identifyPatternIssues(p)
                    })),
                trends: PatternAnalyzer.analyzePatternTrends(filteredPatterns),
                recommendations: PatternAnalyzer.generatePatternRecommendations(filteredPatterns)
            };

            return {
                success: true,
                result: analysis
            };

        } catch (error) {
            this.logger.error('ContextAPI', 'Pattern analysis failed', { error, params });
            return {
                success: false,
                error: `Pattern analysis failed: ${error instanceof Error ? error.message : String(error)}`
            };
        }
    }

    /**
     * Get performance optimization recommendations
     */
    private async optimizePerformance(params: OptimizePerformanceParams): Promise<ToolResult> {
        try {
            this.logger.info('ContextAPI', 'Optimizing performance', params);

            const executions = await this.database.table('tool_executions').find();
            const patterns = await this.mapProcessor.getPatterns();

            let targetExecutions = executions;
            if (params.targetTool) {
                targetExecutions = executions.filter((e: any) => e.tool_name === params.targetTool);
            }

            const optimization = {
                currentPerformance: ExecutionAnalyzer.analyzeCurrentPerformance(targetExecutions),
                bottlenecks: ExecutionAnalyzer.identifyBottlenecks(targetExecutions),
                optimizationOpportunities: ExecutionAnalyzer.identifyOptimizationOpportunities(targetExecutions, patterns),
                recommendations: params.includeRecommendations !== false ? 
                    ExecutionAnalyzer.generateOptimizationRecommendations(targetExecutions, patterns) : [],
                estimatedImpact: ExecutionAnalyzer.estimateOptimizationImpact(targetExecutions)
            };

            return {
                success: true,
                result: optimization
            };

        } catch (error) {
            this.logger.error('ContextAPI', 'Performance optimization failed', { error, params });
            return {
                success: false,
                error: `Performance optimization failed: ${error instanceof Error ? error.message : String(error)}`
            };
        }
    }

    /**
     * Validate Command Map Update - Tool Interface
     * Validates whether a command map update is safe and consistent
     */
    async validateCommandMapUpdate(params: {
        nlpPattern?: string;
        toolName?: string;
        operation?: 'add' | 'update' | 'delete';
        confidence?: number;
    }): Promise<ToolResult> {
        try {
            this.logger.info('ContextIntelligenceAPI', 'Validating command map update', params);

            const { nlpPattern, toolName, operation = 'add', confidence = 0.5 } = params;

            if (!nlpPattern || !toolName) {
                return {
                    success: false,
                    error: 'Missing required parameters: nlpPattern and toolName'
                };
            }

            // Check for pattern conflicts
            const existingPatterns = await this.mapProcessor.getPatterns();
            const hasConflict = existingPatterns.some(pattern => 
                pattern.trigger === nlpPattern && pattern.toolName !== toolName
            );

            if (hasConflict && operation === 'add') {
                return {
                    success: false,
                    error: `Pattern conflict: "${nlpPattern}" already mapped to different tool`,
                    result: { hasPatternConflicts: true }
                };
            }

            // Validate confidence threshold
            if (confidence < 0.1 || confidence > 1.0) {
                return {
                    success: false,
                    error: 'Confidence must be between 0.1 and 1.0'
                };
            }

            return {
                success: true,
                result: {
                    isValid: true,
                    hasPatternConflicts: false,
                    operation,
                    recommendedConfidence: Math.max(confidence, this.config.confidenceThreshold || 0.7)
                }
            };

        } catch (error) {
            this.logger.error('ContextIntelligenceAPI', 'Command map validation failed', { error, params });
            return {
                success: false,
                error: `Validation failed: ${error instanceof Error ? error.message : String(error)}`
            };
        }
    }

    /**
     * Update Pattern Stats - Tool Interface
     * Updates pattern usage statistics and performance metrics
     */
    async updatePatternStats(params: PatternUpdateRequest): Promise<ToolResult> {
        try {
            this.logger.info('ContextIntelligenceAPI', 'Updating pattern stats', {
                toolName: params.toolName,
                success: params.success
            });

            const { nlpPattern, toolName, success, executionTime = 0, metadata = {} } = params;

            // Find the pattern
            const patterns = await this.mapProcessor.getPatterns();
            const pattern = patterns.find(p => 
                p.trigger === nlpPattern || p.toolName === toolName
            );

            if (!pattern) {
                return {
                    success: false,
                    error: `Pattern not found for tool: ${toolName} or pattern: ${nlpPattern}`
                };
            }

            // Update pattern confidence and stats
            await this.mapProcessor.updatePatternConfidence(pattern.id, success, executionTime);

            // Update usage statistics
            if (success) {
                pattern.usageStats.successCount++;
            } else {
                pattern.usageStats.failureCount++;
            }
            pattern.usageStats.lastUsed = new Date();

            // Calculate success rate
            const totalAttempts = pattern.usageStats.successCount + pattern.usageStats.failureCount;
            const successRate = totalAttempts > 0 ? pattern.usageStats.successCount / totalAttempts : 0;

            return {
                success: true,
                result: {
                    patternId: pattern.id,
                    updatedStats: {
                        successCount: pattern.usageStats.successCount,
                        failureCount: pattern.usageStats.failureCount,
                        successRate: successRate,
                        lastUsed: pattern.usageStats.lastUsed,
                        confidence: pattern.confidence
                    },
                    metadata
                }
            };

        } catch (error) {
            this.logger.error('ContextIntelligenceAPI', 'Pattern stats update failed', { error, params });
            return {
                success: false,
                error: `Pattern stats update failed: ${error instanceof Error ? error.message : String(error)}`
            };
        }
    }

    /**
     * Validate Context Tree Update - Tool Interface
     * Validates context tree consistency and structure
     */
    async validateContextTreeUpdate(params: {
        sessionId?: string;
        maxNodes?: number;
        operation?: 'build' | 'update' | 'prune';
    }): Promise<ToolResult> {
        try {
            this.logger.info('ContextIntelligenceAPI', 'Validating context tree update', params);

            const {
                sessionId = this.config.sessionId || 'default',
                maxNodes = 50,
                operation = 'build'
            } = params;

            // Build current context tree for validation
            const contextQuery: ContextQuery = {
                sessionId,
                limit: maxNodes
            };

            const contextTree = await this.treeBuilder.buildContextTree(sessionId, contextQuery);

            // Validate tree structure
            const isConsistent = this.validateTreeConsistency(contextTree);
            const isWithinLimits = contextTree.totalNodes <= maxNodes;
            const hasValidBindings = this.validateTypeBindings(contextTree);

            return {
                success: true,
                result: {
                    isValid: isConsistent && isWithinLimits && hasValidBindings,
                    contextConsistent: isConsistent,
                    withinNodeLimits: isWithinLimits,
                    validTypeBindings: hasValidBindings,
                    currentNodes: contextTree.totalNodes,
                    maxNodes,
                    operation,
                    metrics: {
                        totalNodes: contextTree.totalNodes,
                        toolExecutions: contextTree.metadata.totalToolExecutions,
                        avgConfidence: contextTree.metadata.learningAdaptations
                    }
                }
            };

        } catch (error) {
            this.logger.error('ContextIntelligenceAPI', 'Context tree validation failed', { error, params });
            return {
                success: false,
                error: `Context tree validation failed: ${error instanceof Error ? error.message : String(error)}`
            };
        }
    }

    /**
     * RENAMED: Old method that registered and persisted.
     * Registers a tool's NLP pattern, adds it to the runtime command map, AND persists it.
     * Prefer using NlpService for controlled persistence.
     */
    async registerAndPersistToolNLPMapping(
        toolName: string, 
        nlpPattern: string, 
        metadata: Record<string, any> = {}
    ): Promise<CommandMapPattern | null> {
        try {
            this.logger.info('ContextIntelligenceAPI', 'Registering and Persisting tool NLP mapping', {
                toolName,
                nlpPattern: nlpPattern.substring(0, 50) + '...',
                source: metadata?.source || 'direct_persist_call'
            });

            const toolCallDetails: RuntimeToolCallDetails = {
                name: toolName,
                parameters: metadata.parameters || {}, // Assuming parameters might be in metadata
                confidence: metadata.confidence || 0.7,
                source: metadata.source || 'context_api_persist'
            };
            
            // Calls the method in mapProcessor that handles both memory and DB
            const persistedPattern = await this.mapProcessor.addAndPersistRuntimePattern(nlpPattern, toolCallDetails);

            if (persistedPattern) {
                this.logger.info('ContextIntelligenceAPI', 'Tool NLP mapping registered and persisted successfully', {
                    toolName,
                    patternId: persistedPattern.id
                });
            } else {
                this.logger.warn('ContextIntelligenceAPI', 'Failed to register and persist tool NLP mapping', {toolName});
            }
            return persistedPattern;

        } catch (error) {
            this.logger.error('ContextIntelligenceAPI', 'Failed to register and persist tool NLP mapping', {
                error,
                toolName,
                nlpPattern
            });
            return null;
        }
    }

    /**
     * NEW METHOD: As per IContextIntelligenceAPI for NlpService.
     * Registers an NLP pattern mapping for a tool in the IN-MEMORY command map for runtime use.
     * This does NOT persist the pattern to the database.
     * @param mapping An object containing the tool name, its NLP pattern, and optionally a source.
     */
    async registerToolNlpMapping(
        mapping: { toolName: string; nlpPattern: string; source?: string }
    ): Promise<void> {
        try {
            this.logger.info('ContextIntelligenceAPI', 'Registering tool NLP mapping (in-memory ONLY)', {
                toolName: mapping.toolName,
                nlpPattern: mapping.nlpPattern.substring(0, 50) + '...',
                source: mapping.source
            });

            const toolCallDetails: RuntimeToolCallDetails = {
                name: mapping.toolName,
                parameters: {}, // Defaulting, as this is primarily for runtime command recognition
                confidence: 0.75, // Default confidence for in-memory load
                source: mapping.source || 'nlp_service_runtime_load'
            };

            const patternInMemory = this.mapProcessor.addRuntimePatternToMemory(mapping.nlpPattern, toolCallDetails);

            if (patternInMemory) {
                this.logger.info('ContextIntelligenceAPI', 'Tool NLP mapping registered in-memory successfully', {
                    toolName: mapping.toolName,
                    patternId: patternInMemory.id
                });
            } else {
                 this.logger.warn('ContextIntelligenceAPI', 'Failed to register tool NLP mapping in-memory', {toolName: mapping.toolName});
            }
        } catch (error) {
            this.logger.error('ContextIntelligenceAPI', 'Failed to register tool NLP mapping in-memory', {
                error,
                toolName: mapping.toolName,
                nlpPattern: mapping.nlpPattern
            });
            // Decide if this should throw an error to NlpService
        }
    }

    // Helper methods
    private generateLearningRecommendations(
        toolName: string, 
        success: boolean, 
        feedback?: string
    ): string[] {
        const recommendations: string[] = [];
        
        if (!success) {
            recommendations.push(`Consider parameter adjustment for ${toolName}`);
            recommendations.push('Review tool documentation and usage patterns');
        }
        
        if (feedback === 'negative') {
            recommendations.push('Tool may not be suitable for this use case');
            recommendations.push('Consider alternative tools for similar tasks');
        }
        
        if (feedback === 'positive') {
            recommendations.push(`${toolName} is well-suited for this task type`);
            recommendations.push('Consider adding similar patterns for efficiency');
        }
        
        return recommendations;
    }

    private validateTreeConsistency(contextTree: any): boolean {
        // Basic consistency checks
        return contextTree && 
               contextTree.totalNodes >= 0 && 
               Array.isArray(contextTree.nodes) &&
               contextTree.nodes.length <= contextTree.totalNodes;
    }

    private validateTypeBindings(contextTree: any): boolean {
        // Validate that type bindings are consistent
        return contextTree && 
               contextTree.metadata &&
               typeof contextTree.metadata.learningAdaptations === 'number';
    }

    /**
     * Health check for the Context Intelligence API
     */
    async healthCheck(): Promise<boolean> {
        try {
            // Test database connectivity
            const dbHealthy = await this.database.healthCheck();
            if (!dbHealthy.connected) {
                return false;
            }

            // Test map processor functionality
            const patterns = await this.mapProcessor.getPatterns();
            const mapProcessorHealthy = Array.isArray(patterns);

            // Test basic functionality
            const basicTest = this.config && typeof this.config === 'object';

            return mapProcessorHealthy && basicTest;
        } catch (error) {
            this.logger.error('ContextIntelligenceAPI', 'Health check failed', { error });
            return false;
        }
    }
}
```

## File: /Users/deepsaint/Desktop/symphony-sdk/src/cache/tree-builder.ts

```ts
import { readFileSync } from 'fs';
import { Logger } from '../utils/logger';
import { IDatabaseService, SessionContext } from '../db/IDatabaseService';

export interface ContextNode {
    id: string;
    type: 'tool' | 'workflow' | 'team' | 'task' | 'environment' | 'user_data';
    title: string;
    description?: string;
    timestamp?: Date;
    priority: number;
    children?: ContextNode[];
    metadata?: Record<string, any>;
    executionContext?: {
        toolName?: string;
        parameters?: Record<string, any>;
        result?: any;
        executionTime?: number;
        success?: boolean;
    };
    relationships?: {
        parentId?: string;
        relatedIds?: string[];
        dependencies?: string[];
    };
}

export interface ContextTree {
    sessionId: string;
    rootNodes: ContextNode[];
    totalNodes: number;
    lastUpdated: Date;
    contextDepth: number;
    metadata: {
        sessionStartTime: Date;
        totalToolExecutions: number;
        workflowsActive: number;
        userInteractions: number;
        averageResponseTime: number;
        primaryDomain?: string;
        learningAdaptations: number;
    };
}

export interface ContextQuery {
    sessionId?: string;
    nodeTypes?: string[];
    priority?: number;
    limit?: number;
    includeRelated?: boolean;
    timeWindow?: {
        start: Date;
        end: Date;
    };
    toolNames?: string[];
    keywords?: string[];
}

export class ContextTreeBuilder {
    private static instance: ContextTreeBuilder;
    private logger: Logger;
    private database: IDatabaseService;
    private baseContextTemplate: any;
    private initialized: boolean = false;
    private contextCache = new Map<string, ContextTree>();
    private maxCacheSize = 100;

    private constructor(database: IDatabaseService) {
        this.logger = Logger.getInstance('ContextTreeBuilder');
        this.database = database;
    }

    static getInstance(database: IDatabaseService): ContextTreeBuilder {
        if (!ContextTreeBuilder.instance) {
            ContextTreeBuilder.instance = new ContextTreeBuilder(database);
        } else if (ContextTreeBuilder.instance.database !== database) {
            // If a different database is provided, update the instance
            ContextTreeBuilder.instance.logger.info('ContextTreeBuilder', 'Updating database reference');
            ContextTreeBuilder.instance.database = database;
            ContextTreeBuilder.instance.initialized = false; // Force re-initialization
            ContextTreeBuilder.instance.clearCache(); // Clear cache with old database data
        }
        return ContextTreeBuilder.instance;
    }

    async initialize(contextTemplatePath?: string): Promise<void> {
        if (this.initialized) return;

        this.logger.info('ContextTreeBuilder', 'Initializing context tree builder');

        try {
            // Load base context template
            if (contextTemplatePath) {
                this.baseContextTemplate = JSON.parse(readFileSync(contextTemplatePath, 'utf-8'));
            } else {
                // Default minimal context structure
                this.baseContextTemplate = {
                    environment: {
                        userOS: 'unknown',
                        sessionType: 'interactive',
                        capabilities: []
                    },
                    session: {
                        state: 'active',
                        currentWorkflow: null
                    }
                };
            }

            this.initialized = true;
            this.logger.info('ContextTreeBuilder', 'Context tree builder initialized');
        } catch (error) {
            this.logger.error('ContextTreeBuilder', 'Failed to initialize', { error });
            throw error;
        }
    }

    async buildContextTree(sessionId: string, query?: ContextQuery): Promise<ContextTree> {
        this.logger.info('ContextTreeBuilder', 'Building context tree', { sessionId });

        try {
            // Check cache first
            const cacheKey = this.buildCacheKey(sessionId, query);
            if (this.contextCache.has(cacheKey)) {
                const cached = this.contextCache.get(cacheKey)!;
                
                // Check if cache is still fresh (within 5 minutes)
                if (Date.now() - cached.lastUpdated.getTime() < 5 * 60 * 1000) {
                    this.logger.debug('ContextTreeBuilder', 'Returning cached context tree', { sessionId });
                    return cached;
                }
            }

            // Build fresh context tree
            const contextTree = await this.buildFreshContextTree(sessionId, query);
            
            // Cache the result
            this.cacheContextTree(cacheKey, contextTree);
            
            return contextTree;
        } catch (error) {
            this.logger.error('ContextTreeBuilder', 'Failed to build context tree', { error, sessionId });
            throw error;
        }
    }

    private async buildFreshContextTree(sessionId: string, query?: ContextQuery): Promise<ContextTree> {
        const sessionContext = await this.database.getSessionContext(sessionId);
        const toolExecutions = await this.database.getToolExecutions(sessionId, query?.limit);
        const workflowExecutions = await this.database.getWorkflowExecutions(sessionId);

        // Build root nodes
        const rootNodes: ContextNode[] = [];
        let totalNodes = 0;

        // 1. Environment node (static + session data)
        const environmentNode = this.buildEnvironmentNode(sessionContext || undefined);
        rootNodes.push(environmentNode);
        totalNodes += 1 + (environmentNode.children?.length || 0);

        // 2. Active workflows node
        if (workflowExecutions.length > 0) {
            const workflowNode = this.buildWorkflowNode(workflowExecutions);
            rootNodes.push(workflowNode);
            totalNodes += 1 + (workflowNode.children?.length || 0);
        }

        // 3. Tool execution history
        if (toolExecutions.length > 0) {
            const toolNode = this.buildToolExecutionNode(toolExecutions, query);
            rootNodes.push(toolNode);
            totalNodes += 1 + (toolNode.children?.length || 0);
        }

        // 4. Session state and user data
        const sessionNode = this.buildSessionNode(sessionContext || undefined);
        rootNodes.push(sessionNode);
        totalNodes += 1 + (sessionNode.children?.length || 0);

        // 5. Learning adaptations and patterns
        const learningNode = await this.buildLearningNode(sessionId);
        if (learningNode.children && learningNode.children.length > 0) {
            rootNodes.push(learningNode);
            totalNodes += 1 + learningNode.children.length;
        }

        // Calculate metadata
        const metadata = this.calculateTreeMetadata(sessionContext || undefined, toolExecutions, workflowExecutions);

        return {
            sessionId,
            rootNodes,
            totalNodes,
            lastUpdated: new Date(),
            contextDepth: this.calculateMaxDepth(rootNodes),
            metadata
        };
    }

    private buildEnvironmentNode(sessionContext?: SessionContext): ContextNode {
        const environmentData = this.baseContextTemplate.environment || {};
        
        return {
            id: 'environment',
            type: 'environment',
            title: 'Environment Context',
            description: 'System and user environment information',
            priority: 10,
            metadata: {
                userOS: environmentData.userOS || 'unknown',
                sessionType: environmentData.sessionType || 'interactive',
                capabilities: environmentData.capabilities || [],
                workspaceRoot: sessionContext?.context_data?.workspaceRoot || '',
                currentShell: sessionContext?.context_data?.currentShell || ''
            },
            children: [
                {
                    id: 'environment.system',
                    type: 'environment',
                    title: 'System Information',
                    priority: 8,
                    metadata: {
                        os: environmentData.userOS,
                        shell: sessionContext?.context_data?.currentShell,
                        workspace: sessionContext?.context_data?.workspaceRoot
                    }
                },
                {
                    id: 'environment.capabilities',
                    type: 'environment', 
                    title: 'Available Capabilities',
                    priority: 7,
                    metadata: {
                        tools: environmentData.capabilities || [],
                        features: ['xml_patterns', 'context_trees', 'database_cache']
                    }
                }
            ]
        };
    }

    private buildWorkflowNode(workflowExecutions: any[]): ContextNode {
        const activeWorkflows = workflowExecutions.filter(w => w.status === 'running' || w.status === 'active');
        
        const children = workflowExecutions.slice(0, 10).map((workflow, _index) => ({
            id: `workflow.${workflow.workflow_id}`,
            type: 'workflow' as const,
            title: workflow.workflow_name || `Workflow ${workflow.workflow_id}`,
            description: workflow.description,
            timestamp: new Date(workflow.created_at),
            priority: workflow.status === 'running' ? 9 : 6,
            metadata: {
                status: workflow.status,
                progress: workflow.progress || 0,
                stepCount: workflow.step_count || 0,
                estimatedDuration: workflow.estimated_duration_ms
            }
        }));

        return {
            id: 'workflows',
            type: 'workflow',
            title: 'Active Workflows',
            description: `${activeWorkflows.length} active workflows, ${workflowExecutions.length} total`,
            priority: 9,
            children,
            metadata: {
                activeCount: activeWorkflows.length,
                totalCount: workflowExecutions.length
            }
        };
    }

    private buildToolExecutionNode(toolExecutions: any[], _query?: ContextQuery): ContextNode {
        // Prioritize recent and successful executions
        const sortedExecutions = toolExecutions
            .sort((a, b) => {
                const timeScore = new Date(b.created_at).getTime() - new Date(a.created_at).getTime();
                const successScore = (b.success ? 100 : 0) - (a.success ? 100 : 0);
                return successScore + (timeScore / 1000000); // Time score scaled down
            })
            .slice(0, 15);

        const children = sortedExecutions.map((execution, index) => {
            const priority = this.calculateExecutionPriority(execution, index);
            
            return {
                id: `tool.${execution.execution_id}`,
                type: 'tool' as const,
                title: `${execution.tool_name}`,
                description: this.generateExecutionDescription(execution),
                timestamp: new Date(execution.created_at),
                priority,
                executionContext: {
                    toolName: execution.tool_name,
                    parameters: execution.parameters ? JSON.parse(execution.parameters) : {},
                    result: execution.result ? JSON.parse(execution.result) : null,
                    executionTime: execution.execution_time_ms,
                    success: execution.success
                },
                metadata: {
                    duration: execution.execution_time_ms,
                    success: execution.success,
                    retryCount: execution.retry_count || 0,
                    errorType: execution.error_message ? 'execution_error' : null
                }
            };
        });

        // Group similar tools
        const toolGroups = this.groupExecutionsByTool(children);
        const groupedChildren = Object.entries(toolGroups).map(([toolName, executions]) => ({
            id: `tool_group.${toolName}`,
            type: 'tool' as const,
            title: `${toolName} (${executions.length})`,
            description: `Recent ${toolName} executions`,
            priority: Math.max(...executions.map(e => e.priority)),
            children: executions.slice(0, 5), // Limit sub-items
            metadata: {
                toolName,
                executionCount: executions.length,
                successRate: executions.filter(e => e.executionContext?.success).length / executions.length
            }
        }));

        return {
            id: 'tool_executions',
            type: 'tool',
            title: 'Recent Tool Executions',
            description: `${toolExecutions.length} recent tool executions`,
            priority: 8,
            children: groupedChildren,
            metadata: {
                totalExecutions: toolExecutions.length,
                uniqueTools: new Set(toolExecutions.map(e => e.tool_name)).size,
                averageExecutionTime: toolExecutions.reduce((sum, e) => sum + (e.execution_time_ms || 0), 0) / toolExecutions.length
            }
        };
    }

    private buildSessionNode(sessionContext?: SessionContext): ContextNode {
        const sessionData = sessionContext?.context_data || {};
        
        return {
            id: 'session',
            type: 'user_data',
            title: 'Session Context',
            description: 'Current session state and user data',
            priority: 7,
            metadata: {
                sessionId: sessionContext?.session_id,
                startTime: sessionContext?.started_at,
                lastActivity: sessionContext?.last_activity,
                interactionCount: sessionData.interactionCount || 0,
                currentTask: sessionData.currentTask,
                preferences: sessionData.preferences || {}
            },
            children: [
                {
                    id: 'session.preferences',
                    type: 'user_data',
                    title: 'User Preferences',
                    priority: 5,
                    metadata: sessionData.preferences || {}
                },
                {
                    id: 'session.current_task',
                    type: 'task',
                    title: 'Current Task Context',
                    priority: sessionData.currentTask ? 8 : 3,
                    metadata: {
                        task: sessionData.currentTask,
                        progress: sessionData.taskProgress || 0
                    }
                }
            ]
        };
    }

    private async buildLearningNode(_sessionId: string): Promise<ContextNode> {
        // Get recent pattern learning data
        const patterns = await this.database.getXMLPatterns(true);
        const recentPatterns = patterns
            .filter((p: any) => p.updated_at && new Date(p.updated_at).getTime() > Date.now() - 24 * 60 * 60 * 1000)
            .slice(0, 10);

        const children = recentPatterns.map((pattern: any) => ({
            id: `learning.${pattern.pattern_id}`,
            type: 'task' as const,
            title: `Pattern: ${pattern.pattern_name}`,
            description: `Confidence: ${(pattern.confidence_score * 100).toFixed(1)}%`,
            priority: Math.floor(pattern.confidence_score * 10),
            metadata: {
                patternId: pattern.pattern_id,
                confidence: pattern.confidence_score,
                successCount: pattern.success_count,
                failureCount: pattern.failure_count,
                toolName: pattern.tool_name
            }
        }));

        return {
            id: 'learning',
            type: 'task',
            title: 'Learning Adaptations',
            description: `${recentPatterns.length} recently adapted patterns`,
            priority: 6,
            children,
            metadata: {
                totalPatterns: patterns.length,
                adaptationsToday: recentPatterns.length,
                averageConfidence: recentPatterns.reduce((sum: number, p: any) => sum + p.confidence_score, 0) / (recentPatterns.length || 1)
            }
        };
    }

    private calculateExecutionPriority(execution: any, index: number): number {
        let priority = 5; // Base priority
        
        // Recent executions get higher priority
        const ageInMinutes = (Date.now() - new Date(execution.created_at).getTime()) / (1000 * 60);
        if (ageInMinutes < 5) priority += 3;
        else if (ageInMinutes < 30) priority += 2;
        else if (ageInMinutes < 120) priority += 1;

        // Successful executions get bonus
        if (execution.success) priority += 2;
        
        // Fast executions get slight bonus
        if (execution.execution_time_ms && execution.execution_time_ms < 1000) priority += 1;

        // Position in list affects priority
        priority -= Math.floor(index / 3);

        return Math.max(1, Math.min(10, priority));
    }

    private generateExecutionDescription(execution: any): string {
        const duration = execution.execution_time_ms ? `${execution.execution_time_ms}ms` : 'unknown duration';
        const status = execution.success ? '✓' : '✗';
        
        let paramDesc = '';
        if (execution.parameters) {
            try {
                const params = JSON.parse(execution.parameters);
                const keys = Object.keys(params);
                if (keys.length > 0) {
                    paramDesc = ` with ${keys.slice(0, 2).join(', ')}`;
                    if (keys.length > 2) paramDesc += `, +${keys.length - 2} more`;
                }
            } catch {
                // Ignore parsing errors
            }
        }

        return `${status} Executed in ${duration}${paramDesc}`;
    }

    private groupExecutionsByTool(executions: ContextNode[]): Record<string, ContextNode[]> {
        const groups: Record<string, ContextNode[]> = {};
        
        for (const execution of executions) {
            const toolName = execution.executionContext?.toolName || 'unknown';
            if (!groups[toolName]) {
                groups[toolName] = [];
            }
            groups[toolName].push(execution);
        }

        return groups;
    }

    private calculateMaxDepth(nodes: ContextNode[]): number {
        let maxDepth = 1;
        
        for (const node of nodes) {
            if (node.children && node.children.length > 0) {
                const childDepth = 1 + this.calculateMaxDepth(node.children);
                maxDepth = Math.max(maxDepth, childDepth);
            }
        }

        return maxDepth;
    }

    private calculateTreeMetadata(
        sessionContext?: SessionContext,
        toolExecutions: any[] = [],
        workflowExecutions: any[] = []
    ) {
        const now = Date.now();
        const sessionStart = sessionContext?.started_at ? new Date(sessionContext.started_at).getTime() : now;
        
        // Calculate average response time from recent executions
        const recentExecutions = toolExecutions.filter(e => 
            e.execution_time_ms && (now - new Date(e.created_at).getTime()) < 60 * 60 * 1000
        );
        const averageResponseTime = recentExecutions.length > 0 
            ? recentExecutions.reduce((sum, e) => sum + e.execution_time_ms, 0) / recentExecutions.length
            : 0;

        // Determine primary domain from tool usage
        const toolCounts: Record<string, number> = {};
        toolExecutions.forEach(e => {
            toolCounts[e.tool_name] = (toolCounts[e.tool_name] || 0) + 1;
        });
        const primaryTool = Object.entries(toolCounts).sort(([,a], [,b]) => b - a)[0]?.[0];
        
        return {
            sessionStartTime: new Date(sessionStart),
            totalToolExecutions: toolExecutions.length,
            workflowsActive: workflowExecutions.filter(w => w.status === 'running').length,
            userInteractions: sessionContext?.context_data?.interactionCount || 0,
            averageResponseTime,
            primaryDomain: this.mapToolToDomain(primaryTool),
            learningAdaptations: 0 // Will be filled by learning node if present
        };
    }

    private mapToolToDomain(toolName?: string): string | undefined {
        if (!toolName) return undefined;
        
        const domainMap: Record<string, string> = {
            'web_search': 'research',
            'file_search': 'development',
            'edit_file': 'development',
            'run_terminal_cmd': 'system_admin',
            'codebase_search': 'development',
            'list_dir': 'file_management'
        };

        return domainMap[toolName] || 'general';
    }

    private buildCacheKey(sessionId: string, query?: ContextQuery): string {
        const queryHash = query ? JSON.stringify(query) : 'default';
        return `${sessionId}:${queryHash}`;
    }

    private cacheContextTree(key: string, tree: ContextTree): void {
        // Implement LRU cache
        if (this.contextCache.size >= this.maxCacheSize) {
            const firstKey = this.contextCache.keys().next().value;
            if (firstKey) {
                this.contextCache.delete(firstKey);
            }
        }
        
        this.contextCache.set(key, tree);
        this.logger.debug('ContextTreeBuilder', 'Cached context tree', { 
            key: key.substring(0, 20) + '...', 
            nodes: tree.totalNodes 
        });
    }

    async getContextForPrompt(sessionId: string, options?: {
        maxNodes?: number;
        includeLowPriority?: boolean;
        focusAreas?: string[];
    }): Promise<string> {
        const tree = await this.buildContextTree(sessionId);
        
        // Convert tree to prompt-friendly format
        const maxNodes = options?.maxNodes || 50;
        const includeLowPriority = options?.includeLowPriority || false;
        const minPriority = includeLowPriority ? 1 : 5;

        const relevantNodes = this.flattenTree(tree.rootNodes)
            .filter(node => node.priority >= minPriority)
            .sort((a, b) => b.priority - a.priority)
            .slice(0, maxNodes);

        return this.formatNodesForPrompt(relevantNodes, tree.metadata);
    }

    private flattenTree(nodes: ContextNode[], depth = 0): ContextNode[] {
        const flattened: ContextNode[] = [];
        
        for (const node of nodes) {
            flattened.push({ ...node, metadata: { ...node.metadata, depth } });
            
            if (node.children && node.children.length > 0) {
                flattened.push(...this.flattenTree(node.children, depth + 1));
            }
        }

        return flattened;
    }

    private formatNodesForPrompt(nodes: ContextNode[], metadata: any): string {
        const sections: string[] = [];
        
        // Add session overview
        sections.push(`**Session Context** (${metadata.totalToolExecutions} tools, ${metadata.userInteractions} interactions)`);
        
        // Group nodes by type
        const nodesByType = nodes.reduce((groups, node) => {
            if (!groups[node.type]) groups[node.type] = [];
            groups[node.type].push(node);
            return groups;
        }, {} as Record<string, ContextNode[]>);

        // Format each type
        for (const [type, typeNodes] of Object.entries(nodesByType)) {
            if (typeNodes.length === 0) continue;
            
            sections.push(`\n**${type.toUpperCase()}:**`);
            
            typeNodes.slice(0, 10).forEach(node => {
                const indent = '  '.repeat((node.metadata?.depth || 0));
                const priority = node.priority >= 8 ? '🔥' : node.priority >= 6 ? '⭐' : '';
                sections.push(`${indent}- ${priority} ${node.title}: ${node.description || ''}`);
            });
        }

        return sections.join('\n');
    }

    clearCache(): void {
        this.contextCache.clear();
        this.logger.info('ContextTreeBuilder', 'Cleared context cache');
    }

    getCacheStats(): { size: number; maxSize: number; hitRate?: number } {
        return {
            size: this.contextCache.size,
            maxSize: this.maxCacheSize
        };
    }
} 
```

## File: /Users/deepsaint/Desktop/symphony-sdk/src/cache/index.ts

```ts
import { Logger } from '../utils/logger';
import { IDatabaseService, SetOptions } from '../db/IDatabaseService';

// Legacy cache interface for backward compatibility
export interface CacheEntry {
    key: string;
    value: any;
    timestamp: number;
    ttl?: number;
    namespace?: string;
}

export interface CacheOptions {
    defaultTTL?: number;
    maxSize?: number;
    cleanupInterval?: number;
}

// Legacy cache implementation - now delegates to database service
export class Cache {
    private logger: Logger;
    private database?: IDatabaseService;
    private options: CacheOptions;

    constructor(options: CacheOptions = {}) {
        this.logger = Logger.getInstance('Cache');
        this.options = {
            defaultTTL: options.defaultTTL || 300000, // 5 minutes
            maxSize: options.maxSize || 1000,
            cleanupInterval: options.cleanupInterval || 60000, // 1 minute
            ...options
        };
    }

    setDatabase(database: IDatabaseService): void {
        this.database = database;
    }

    async get(key: string, namespace?: string): Promise<any> {
        if (!this.database) {
            this.logger.warn('Cache', 'Database service not available, cache get failed', { key });
            return null;
        }

        try {
            return await this.database.get(key, namespace);
        } catch (error) {
            this.logger.error('Cache', 'Failed to get cache entry', { error, key, namespace });
            return null;
        }
    }

    async set(key: string, value: any, ttl?: number, namespace?: string): Promise<void> {
        if (!this.database) {
            this.logger.warn('Cache', 'Database service not available, cache set failed', { key });
            return;
        }

        try {
            const options: SetOptions = {
                ttl: ttl ? Math.floor(ttl / 1000) : Math.floor((this.options.defaultTTL || 300000) / 1000), // Convert ms to seconds
                namespace
            };
            await this.database.set(key, value, options);
        } catch (error) {
            this.logger.error('Cache', 'Failed to set cache entry', { error, key, namespace });
        }
    }

    async delete(key: string, namespace?: string): Promise<void> {
        if (!this.database) {
            this.logger.warn('Cache', 'Database service not available, cache delete failed', { key });
            return;
        }

        try {
            await this.database.delete(key, namespace);
        } catch (error) {
            this.logger.error('Cache', 'Failed to delete cache entry', { error, key, namespace });
        }
    }

    async has(key: string, namespace?: string): Promise<boolean> {
        if (!this.database) {
            return false;
        }

        try {
            const value = await this.database.get(key, namespace);
            return value !== null;
        } catch (error) {
            this.logger.error('Cache', 'Failed to check cache entry', { error, key, namespace });
            return false;
        }
    }

    async clear(namespace?: string): Promise<void> {
        if (!this.database) {
            this.logger.warn('Cache', 'Database service not available, cache clear failed');
            return;
        }

        try {
            // Since IDatabaseService doesn't have a clear method, we'll use find + delete
            const pattern = namespace ? `${namespace}:*` : '*';
            const entries = await this.database.find(pattern, {}, namespace);
            
            for (const entry of entries) {
                if (entry.key) {
                    await this.database.delete(entry.key, namespace);
                }
            }
        } catch (error) {
            this.logger.error('Cache', 'Failed to clear cache', { error, namespace });
        }
    }

    async size(namespace?: string): Promise<number> {
        if (!this.database) {
            return 0;
        }

        try {
            // Since IDatabaseService doesn't have a size method, we'll use find to count
            const pattern = namespace ? `${namespace}:*` : '*';
            const entries = await this.database.find(pattern, {}, namespace);
            return entries.length;
        } catch (error) {
            this.logger.error('Cache', 'Failed to get cache size', { error, namespace });
            return 0;
        }
    }

    async keys(namespace?: string): Promise<string[]> {
        if (!this.database) {
            return [];
        }

        try {
            // Since IDatabaseService doesn't have a keys method, we'll use find to get keys
            const pattern = namespace ? `${namespace}:*` : '*';
            const entries = await this.database.find(pattern, {}, namespace);
            return entries.map(entry => entry.key).filter(Boolean);
        } catch (error) {
            this.logger.error('Cache', 'Failed to get cache keys', { error, namespace });
            return [];
        }
    }

    getStats() {
        return {
            options: this.options,
            databaseConnected: !!this.database
        };
    }
}

// Export new cache intelligence services
export { CommandMapProcessor } from './map-processor';
export { ContextTreeBuilder } from './tree-builder';
export { CacheIntelligenceService } from './service';

// Export types
export type {
    Variable,
    Pattern,
    PatternMatch,
    CacheResult
} from './map-processor';

export type {
    ContextNode,
    ContextTree,
    ContextQuery
} from './tree-builder';

export type {
    IntelligenceOptions,
    IntelligenceResult,
    SessionIntelligence
} from './service';

// Backward compatibility function
let globalCache: Cache | null = null;

export function getCache(options?: CacheOptions, database?: IDatabaseService): Cache {
    if (!globalCache) {
        globalCache = new Cache(options);
        // Set database if provided
        if (database) {
            globalCache.setDatabase(database);
        }
    } else if (database && !globalCache.getStats().databaseConnected) {
        // If cache exists but database not connected, connect it
        globalCache.setDatabase(database);
    }
    return globalCache;
}

export function clearCache(): void {
    if (globalCache) {
        globalCache.clear();
    }
}

// Export default object for backward compatibility
export default {
    getCache,
    clearCache,
    Cache
}; 
```

## File: /Users/deepsaint/Desktop/symphony-sdk/src/cache/service.ts

```ts
import { CommandMapProcessor, CacheResult, PatternMatch } from './map-processor';
import { ContextTreeBuilder, ContextTree, ContextQuery } from './tree-builder';
import { Logger } from '../utils/logger';
import { IDatabaseService } from '../db/IDatabaseService';

export interface IntelligenceOptions {
    enablePatternMatching?: boolean;
    enableContextTrees?: boolean;
    fastPathThreshold?: number;
    contextMaxNodes?: number;
    includeLowPriorityContext?: boolean;
    sessionId?: string;
    xmlPatternPath?: string;
    contextTemplatePath?: string;
}

export interface IntelligenceResult {
    // Pattern matching results
    patternMatch?: {
        found: boolean;
        confidence: number;
        shouldUseFastPath: boolean;
        executionTime: number;
        match?: PatternMatch;
    };
    
    // Context tree results  
    contextTree?: ContextTree;
    contextPrompt?: string;
    
    // Combined intelligence
    recommendation: {
        action: 'fast_path' | 'standard_path' | 'enhanced_context' | 'no_match';
        confidence: number;
        reasoning: string;
        suggestedTools?: string[];
        contextPriority: 'high' | 'medium' | 'low';
    };
    
    // Performance metrics
    performance: {
        totalTime: number;
        patternMatchTime: number;
        contextBuildTime: number;
        cacheHits: number;
        cacheMisses: number;
    };
    
    // Metadata
    metadata: {
        sessionId?: string;
        timestamp: Date;
        serviceVersion: string;
        featuresUsed: string[];
    };
}

export interface SessionIntelligence {
    sessionId: string;
    totalQueries: number;
    fastPathUsage: number;
    averageConfidence: number;
    topPatterns: string[];
    contextComplexity: number;
    learningProgress: number;
}

export class CacheIntelligenceService {
    private static instance: CacheIntelligenceService;
    private commandMapProcessor: CommandMapProcessor;
    private contextTreeBuilder: ContextTreeBuilder;
    private logger: Logger;
    private database: IDatabaseService;
    private initialized: boolean = false;
    
    // Session tracking
    private sessionStats = new Map<string, SessionIntelligence>();
    private globalStats = {
        totalQueries: 0,
        fastPathQueries: 0,
        patternMatches: 0,
        contextTreeBuilds: 0,
        cacheHits: 0,
        cacheMisses: 0
    };

    private constructor(database: IDatabaseService) {
        this.logger = Logger.getInstance('CacheIntelligenceService');
        this.database = database;
        this.commandMapProcessor = CommandMapProcessor.getInstance(database);
        this.contextTreeBuilder = ContextTreeBuilder.getInstance(database);
    }

    static getInstance(database: IDatabaseService): CacheIntelligenceService {
        if (!CacheIntelligenceService.instance) {
            CacheIntelligenceService.instance = new CacheIntelligenceService(database);
        } else if (CacheIntelligenceService.instance.database !== database) {
            // If a different database is provided, update all references
            CacheIntelligenceService.instance.logger.info('CacheIntelligenceService', 'Updating database reference');
            CacheIntelligenceService.instance.database = database;
            // Update sub-services with new database
            CacheIntelligenceService.instance.commandMapProcessor = CommandMapProcessor.getInstance(database);
            CacheIntelligenceService.instance.contextTreeBuilder = ContextTreeBuilder.getInstance(database);
            CacheIntelligenceService.instance.initialized = false; // Force re-initialization
        }
        return CacheIntelligenceService.instance;
    }

    async initialize(options: IntelligenceOptions = {}): Promise<void> {
        if (this.initialized) return;

        this.logger.info('CacheIntelligenceService', 'Initializing cache intelligence service');

        try {
            // Initialize sub-services
            if (options.enablePatternMatching !== false) {
                await this.commandMapProcessor.initialize(options.xmlPatternPath);
                
                if (options.fastPathThreshold) {
                    this.commandMapProcessor.setFastPathThreshold(options.fastPathThreshold);
                }
            }

            if (options.enableContextTrees !== false) {
                await this.contextTreeBuilder.initialize(options.contextTemplatePath);
            }

            this.initialized = true;
            this.logger.info('CacheIntelligenceService', 'Cache intelligence service initialized successfully');
        } catch (error) {
            this.logger.error('CacheIntelligenceService', 'Failed to initialize', { error });
            throw error;
        }
    }

    async getIntelligence(
        userInput: string, 
        options: IntelligenceOptions = {}
    ): Promise<IntelligenceResult> {
        const startTime = Date.now();
        const sessionId = options.sessionId || 'default';
        
        this.logger.info('CacheIntelligenceService', 'Getting intelligence for user input', {
            input: userInput.substring(0, 100),
            sessionId
        });

        try {
            const featuresUsed: string[] = [];
            let patternResult: CacheResult | undefined;
            let contextTree: ContextTree | undefined;
            let contextPrompt: string | undefined;
            
            const patternStartTime = Date.now();
            
            // 1. Pattern Matching (if enabled)
            if (options.enablePatternMatching !== false) {
                featuresUsed.push('pattern_matching');
                patternResult = await this.commandMapProcessor.processUserInput(userInput, sessionId);
                this.globalStats.patternMatches++;
                
                if (patternResult.matched) {
                    this.logger.info('CacheIntelligenceService', 'Pattern match found', {
                        confidence: patternResult.confidence?.toFixed(3),
                        pattern: patternResult.patternMatch?.pattern.id,
                        fastPath: patternResult.shouldUseFastPath
                    });
                }
            }
            
            const patternTime = Date.now() - patternStartTime;
            const contextStartTime = Date.now();
            
            // 2. Context Tree Building (if enabled and beneficial)
            if (options.enableContextTrees !== false) {
                const shouldBuildContext = this.shouldBuildContext(patternResult, userInput);
                
                if (shouldBuildContext) {
                    featuresUsed.push('context_trees');
                    
                    const contextQuery: ContextQuery = {
                        sessionId,
                        limit: options.contextMaxNodes || 50
                    };
                    
                    contextTree = await this.contextTreeBuilder.buildContextTree(sessionId, contextQuery);
                    this.globalStats.contextTreeBuilds++;
                    
                    // Generate context prompt
                    contextPrompt = await this.contextTreeBuilder.getContextForPrompt(sessionId, {
                        maxNodes: options.contextMaxNodes || 50,
                        includeLowPriority: options.includeLowPriorityContext || false
                    });
                }
            }
            
            const contextTime = Date.now() - contextStartTime;
            
            // 3. Generate combined recommendation
            const recommendation = this.generateRecommendation(patternResult, contextTree, userInput);
            
            // 4. Update statistics
            this.updateSessionStats(sessionId, patternResult, recommendation);
            this.globalStats.totalQueries++;
            if (recommendation.action === 'fast_path') {
                this.globalStats.fastPathQueries++;
            }
            
            const totalTime = Date.now() - startTime;
            
            return {
                patternMatch: patternResult ? {
                    found: patternResult.matched,
                    confidence: patternResult.confidence,
                    shouldUseFastPath: patternResult.shouldUseFastPath,
                    executionTime: patternResult.executionTime,
                    match: patternResult.patternMatch
                } : undefined,
                
                contextTree,
                contextPrompt,
                recommendation,
                
                performance: {
                    totalTime,
                    patternMatchTime: patternTime,
                    contextBuildTime: contextTime,
                    cacheHits: this.globalStats.cacheHits,
                    cacheMisses: this.globalStats.cacheMisses
                },
                
                metadata: {
                    sessionId,
                    timestamp: new Date(),
                    serviceVersion: '1.0.0',
                    featuresUsed
                }
            };
        } catch (error) {
            this.logger.error('CacheIntelligenceService', 'Failed to get intelligence', { error, userInput });
            
            // Return fallback result
            return this.createFallbackResult(userInput, sessionId, Date.now() - startTime);
        }
    }

    private shouldBuildContext(patternResult?: CacheResult, userInput?: string): boolean {
        // Always build context if no pattern match
        if (!patternResult || !patternResult.matched) {
            return true;
        }
        
        // Build context if pattern confidence is low-medium
        if (patternResult.confidence < 0.75) {
            return true;
        }
        
        // Build context for complex queries (long input, questions, analysis requests)
        if (userInput && (
            userInput.length > 100 ||
            userInput.includes('?') ||
            /analyze|explain|understand|context|why|how/.test(userInput.toLowerCase())
        )) {
            return true;
        }
        
        return false;
    }

    private generateRecommendation(
        patternResult?: CacheResult, 
        contextTree?: ContextTree, 
        _userInput?: string
    ) {
        // High confidence pattern match -> Fast path
        if (patternResult?.matched && patternResult.shouldUseFastPath) {
            return {
                action: 'fast_path' as const,
                confidence: patternResult.confidence,
                reasoning: `High confidence pattern match (${(patternResult.confidence * 100).toFixed(1)}%) for "${patternResult.patternMatch?.pattern.id}"`,
                suggestedTools: patternResult.patternMatch ? [patternResult.patternMatch.toolCall.name] : undefined,
                contextPriority: 'low' as const
            };
        }
        
        // Medium confidence pattern + rich context -> Enhanced context
        if (patternResult?.matched && contextTree && contextTree.totalNodes > 10) {
            return {
                action: 'enhanced_context' as const,
                confidence: Math.min(0.85, patternResult.confidence + 0.1),
                reasoning: `Pattern match with rich session context (${contextTree.totalNodes} context nodes)`,
                suggestedTools: patternResult.patternMatch ? [patternResult.patternMatch.toolCall.name] : undefined,
                contextPriority: 'high' as const
            };
        }
        
        // Low confidence pattern or no pattern + context -> Standard path with context
        if (contextTree && contextTree.totalNodes > 5) {
            const confidence = patternResult?.confidence || 0.3;
            return {
                action: 'standard_path' as const,
                confidence,
                reasoning: `Using standard path with session context (${contextTree.totalNodes} nodes, ${contextTree.metadata.totalToolExecutions} tool executions)`,
                contextPriority: 'medium' as const
            };
        }
        
        // Fallback
        return {
            action: 'no_match' as const,
            confidence: 0.1,
            reasoning: 'No pattern match and minimal context available',
            contextPriority: 'low' as const
        };
    }

    private updateSessionStats(sessionId: string, patternResult?: CacheResult, recommendation?: any): void {
        if (!this.sessionStats.has(sessionId)) {
            this.sessionStats.set(sessionId, {
                sessionId,
                totalQueries: 0,
                fastPathUsage: 0,
                averageConfidence: 0,
                topPatterns: [],
                contextComplexity: 0,
                learningProgress: 0
            });
        }
        
        const stats = this.sessionStats.get(sessionId)!;
        stats.totalQueries++;
        
        if (recommendation?.action === 'fast_path') {
            stats.fastPathUsage++;
        }
        
        if (patternResult?.confidence) {
            stats.averageConfidence = (stats.averageConfidence + patternResult.confidence) / 2;
        }
        
        // Track top patterns
        if (patternResult?.patternMatch?.pattern.id) {
            const patternId = patternResult.patternMatch.pattern.id;
            if (!stats.topPatterns.includes(patternId)) {
                stats.topPatterns.push(patternId);
                if (stats.topPatterns.length > 10) {
                    stats.topPatterns = stats.topPatterns.slice(-10);
                }
            }
        }
    }

    private createFallbackResult(_userInput: string, sessionId: string, executionTime: number): IntelligenceResult {
        return {
            recommendation: {
                action: 'standard_path',
                confidence: 0.1,
                reasoning: 'Fallback to standard path due to intelligence service error',
                contextPriority: 'low'
            },
            performance: {
                totalTime: executionTime,
                patternMatchTime: 0,
                contextBuildTime: 0,
                cacheHits: 0,
                cacheMisses: 1
            },
            metadata: {
                sessionId,
                timestamp: new Date(),
                serviceVersion: '1.0.0',
                featuresUsed: ['fallback']
            }
        };
    }

    // Tool execution feedback methods
    public async recordToolExecution(
        sessionId: string,
        toolName: string,
        parameters: Record<string, any>,
        result: any,
        success: boolean,
        executionTime: number,
        patternId?: string
    ): Promise<void> {
        try {
            // Update pattern confidence if this was a pattern-matched execution
            if (patternId) {
                await this.commandMapProcessor.updatePatternConfidence(patternId, success, executionTime);
            }

            let patternDbId: number | undefined;
            if (patternId) {
                const dbPatterns = await this.database.getXMLPatterns();
                const matchingPattern = dbPatterns.find(p => p.pattern_id === patternId);
                if (matchingPattern) {
                    patternDbId = matchingPattern.id;
                }
            }
            
            // Record in database for context building
            await this.database.recordToolExecution({
                execution_id: `tool_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`,
                tool_name: toolName,
                parameters: JSON.stringify(parameters),
                result: JSON.stringify(result),
                success,
                execution_time_ms: executionTime,
                session_id: sessionId,
                error_details: success ? undefined : (result?.error || 'Unknown error'),
                pattern_id: patternDbId
            });
            
            this.logger.info('CacheIntelligenceService', 'Recorded tool execution', {
                sessionId,
                toolName,
                success,
                executionTime,
                patternId
            });
        } catch (error) {
            this.logger.error('CacheIntelligenceService', 'Failed to record tool execution', { 
                error, sessionId, toolName 
            });
        }
    }

    async adaptPattern(patternId: string, userFeedback: 'positive' | 'negative', _context?: any): Promise<void> {
        try {
            const pattern = await this.commandMapProcessor.getPattern(patternId);
            if (!pattern) {
                this.logger.warn('CacheIntelligenceService', 'Cannot adapt unknown pattern', { patternId });
                return;
            }
            
            // Adjust confidence based on feedback
            const adjustment = userFeedback === 'positive' ? 0.05 : -0.1;
            const newConfidence = Math.max(0.1, Math.min(0.99, pattern.confidence + adjustment));
            
            await this.commandMapProcessor.updatePatternConfidence(
                patternId, 
                userFeedback === 'positive', 
                0 // No execution time for manual feedback
            );
            
            this.logger.info('CacheIntelligenceService', 'Adapted pattern based on user feedback', {
                patternId,
                feedback: userFeedback,
                oldConfidence: pattern.confidence.toFixed(3),
                newConfidence: newConfidence.toFixed(3)
            });
        } catch (error) {
            this.logger.error('CacheIntelligenceService', 'Failed to adapt pattern', { error, patternId });
        }
    }

    // Analytics and monitoring
    getSessionIntelligence(sessionId: string): SessionIntelligence | undefined {
        return this.sessionStats.get(sessionId);
    }

    getGlobalStats() {
        return {
            ...this.globalStats,
            sessions: this.sessionStats.size,
            averageFastPathRate: this.globalStats.totalQueries > 0 ? 
                this.globalStats.fastPathQueries / this.globalStats.totalQueries : 0,
            patternMatchRate: this.globalStats.totalQueries > 0 ?
                this.globalStats.patternMatches / this.globalStats.totalQueries : 0
        };
    }

    async getPatternAnalytics() {
        const patterns = await this.commandMapProcessor.getPatterns();
        
        return {
            totalPatterns: patterns.length,
            averageConfidence: patterns.length > 0 ? patterns.reduce((sum, p) => sum + p.confidence, 0) / patterns.length : 0,
            topPatterns: patterns
                .sort((a, b) => b.usageStats.successCount - a.usageStats.successCount)
                .slice(0, 10)
                .map(p => ({
                    id: p.id,
                    confidence: p.confidence,
                    successCount: p.usageStats.successCount,
                    failureCount: p.usageStats.failureCount,
                    successRate: p.usageStats.successCount / (p.usageStats.successCount + p.usageStats.failureCount)
                })),
            patternsByTool: patterns.reduce((groups, pattern) => {
                if (!groups[pattern.toolName]) groups[pattern.toolName] = [];
                groups[pattern.toolName].push(pattern.id);
                return groups;
            }, {} as Record<string, string[]>)
        };
    }

    async getContextAnalytics() {
        const stats = this.contextTreeBuilder.getCacheStats();
        
        return {
            cacheStats: stats,
            contextTreeBuilds: this.globalStats.contextTreeBuilds,
            averageTreeComplexity: 0 // Could be calculated from recent builds
        };
    }

    // Utility methods
    clearCaches(): void {
        this.contextTreeBuilder.clearCache();
        this.logger.info('CacheIntelligenceService', 'Cleared all caches');
    }

    async healthCheck(): Promise<{
        status: 'healthy' | 'degraded' | 'unhealthy';
        cacheHits: number;
        cacheMisses: number;
        totalPatterns: number;
        activeContexts: number;
        uptime: number;
    }> {
        const patterns = await this.commandMapProcessor.getPatterns();
        return {
            status: 'healthy',
            cacheHits: this.globalStats.cacheHits,
            cacheMisses: this.globalStats.cacheMisses,
            totalPatterns: patterns.length,
            activeContexts: this.sessionStats.size,
            uptime: Date.now() - Date.now() // Simple uptime placeholder
        };
    }

    getCommandMapProcessor(): CommandMapProcessor {
        return this.commandMapProcessor;
    }
} 
```

## File: /Users/deepsaint/Desktop/symphony-sdk/src/cache/context-tree.json

```json
{
    "agent_state": {
        "active_tools": [
            {
                "id": "codebase_search",
                "status": "ready",
                "last_check": "2024-03-14T17:45:00Z",
                "health": {
                    "success_rate": 0.97,
                    "avg_latency": "150ms",
                    "error_rate": 0.03
                }
            },
            {
                "id": "read_file",
                "status": "ready",
                "last_check": "2024-03-14T17:44:30Z",
                "health": {
                    "success_rate": 0.99,
                    "avg_latency": "85ms",
                    "error_rate": 0.01
                }
            },
            {
                "id": "edit_file",
                "status": "ready",
                "last_check": "2024-03-14T17:44:45Z",
                "health": {
                    "success_rate": 0.92,
                    "avg_latency": "200ms",
                    "error_rate": 0.08
                }
            },
            {
                "id": "grep_search",
                "status": "ready",
                "last_check": "2024-03-14T17:45:15Z",
                "health": {
                    "success_rate": 0.95,
                    "avg_latency": "180ms",
                    "error_rate": 0.05
                }
            }
        ],
        "type_registry": {
            "string": {
                "validators": ["non_empty", "max_length_1000"],
                "transformers": ["trim", "normalize_path"]
            },
            "number": {
                "validators": ["positive", "max_value_1000000"],
                "transformers": ["parse_int", "clamp"]
            },
            "boolean": {
                "validators": ["strict_bool"],
                "transformers": ["to_boolean"]
            }
        }
    },

    "runtime": {
        "system": {
            "os": "darwin",
            "memory_available": "16GB",
            "cpu_cores": 8,
            "workspace_path": "/Users/saint/Desktop/symphonic"
        },
        "metrics": {
            "tool_calls": 487,
            "pattern_matches": 423,
            "cache_hits": 368,
            "avg_response_time": "175ms",
            "success_rate": 0.94
        },
        "constraints": {
            "max_concurrent_tools": 4,
            "max_memory_per_tool": "1GB",
            "max_execution_time": "30s",
            "require_approval": ["delete_file", "run_terminal_cmd"]
        }
    },

    "execution": {
        "active_patterns": [
            {
                "id": "FILE_SEARCH",
                "confidence": 0.95,
                "last_success": "2024-03-14T17:43:00Z",
                "vars": {
                    "query": "interface",
                    "target": "src/"
                }
            }
        ],
        "current_tools": [
            {
                "id": "tool_exec_789",
                "tool": "codebase_search",
                "start_time": "2024-03-14T17:45:20Z",
                "status": "running",
                "params": {
                    "query": "interface",
                    "target_directories": ["src/"]
                }
            }
        ],
        "recent_results": [
            {
                "id": "tool_exec_788",
                "tool": "read_file",
                "success": true,
                "latency": "82ms",
                "pattern_id": "FILE_READ",
                "timestamp": "2024-03-14T17:45:15Z"
            },
            {
                "id": "tool_exec_787",
                "tool": "edit_file",
                "success": true,
                "latency": "195ms",
                "pattern_id": "EDIT_FILE",
                "timestamp": "2024-03-14T17:44:30Z"
            }
        ]
    },

    "learning": {
        "pattern_evolution": {
            "threshold": 0.8,
            "min_samples": 10,
            "learning_rate": 0.05,
            "decay_rate": 0.01
        },
        "type_inference": {
            "confidence_threshold": 0.9,
            "sample_size": 50,
            "update_frequency": "1h"
        },
        "performance_optimization": {
            "cache_ttl": "1h",
            "prune_threshold": 0.7,
            "max_patterns": 100,
            "min_confidence": 0.85
        }
    },

    "validation": {
        "rules": {
            "tool_execution": [
                "type_check",
                "permission_check",
                "resource_check",
                "safety_check"
            ],
            "pattern_matching": [
                "confidence_threshold",
                "variable_binding",
                "context_consistency"
            ],
            "state_updates": [
                "atomic_operation",
                "rollback_support",
                "audit_logging"
            ]
        },
        "thresholds": {
            "min_confidence": 0.8,
            "max_latency": "500ms",
            "error_threshold": 0.1,
            "warning_threshold": 0.05
        }
    },

    "meta": {
        "version": "1.0.0",
        "last_update": "2024-03-14T17:45:30Z",
        "update_frequency": "1s",
        "maintenance_window": "0 0 * * *"
    }
} 
```



---

> 📸 Generated with [Jockey CLI](https://github.com/saint0x/jockey-cli)
